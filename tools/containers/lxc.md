Linux Containers
================

## Overview

- <https://linuxcontainers.org/>
  - <https://github.com/lxc/distrobuilder>
  - <https://github.com/lxc/lxc>
  - <https://github.com/lxc/incus>

## distrobuilder

- <https://github.com/lxc/distrobuilder>
- <https://github.com/lxc/lxc-ci> has image definition files used by CI
  - many options are overriden by `-o` at runtime
- example
  - `test.yaml`
    - `image:`
      - `distribution: test`
      - `release: 3.20`
    - `source:`
      - `downloader: alpinelinux-http`
      - `url: https://dl-cdn.alpinelinux.org/alpine/`
    - `packages:`
      - `manager: apk`
  - `sudo distrobuilder build-dir test.yaml test`
    - downloads
      <https://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/alpine-minirootfs-3.20.3-x86_64.tar.gz>
      to `/tmp/distrobuilder/test-3.20-x86_64/alpine-minirootfs-3.20.3-x86_64.tar.gz`
    - unpacks the tarball to `test`
- a real image definition file typically also has
  - `packages.sets.packages`, to install/remove packages
  - `files`, to generate files such as `/etc/hostname`, etc.
  - `actions`, to run scripts at different stages
- systemd workaround
  - <https://github.com/systemd/systemd/commit/bf331d87171b7750d1c72ab0b140a240c0cf32c3>
    - the commit assume udev works properly if `/sys` is mounted rw
  - when lxc mounts `/sys` rw (e.g., when `security.nesting=true` in lxd),
    systemd-networkd is broken
    - the symptom is dhcpv4 does not work
  - container images generated by <https://github.com/lxc/distrobuilder> has a
    workaround
    - distrobuilder generates `/etc/systemd/system-generators/lxc` which sets
      `BindReadOnlyPaths=/sys` for systemd-networkd
    - the workaround is restricted to
      - arch or fedora (this seems too restrictive)
      - unprivilieged containers (the comment is incorrect)
      - `security.nesting=false` (this is incorrect too)
  - `systemctl edit systemd-networkd` to manually add the workaround
    - `[Service]`
    - `BindReadOnlyPaths=/sys`

## LXC

- <https://github.com/lxc/lxc>
- `lxc-checkconfig` checks if kernel has the required feature
- `lxc-create -n test -t download` creates a container named `test`
  - it executes `/usr/share/lxc/templates/lxc-download` to download an image
    from <https://images.linuxcontainers.org/>
  - the container is under `/var/lib/lxc/test`
- `lxc-ls -f` lists containers
  - this includes their states such as `STOPPED`, `RUNNING`, etc.
- `lxc-start -n test` starts the container
  - this starts the container and runs `/sbin/init`
  - all processes in the container are regular processes and show up in the
    host `ps -ef` as well
  - but they are in a different pid ns
  - `lxc-start -n test -o log -l DEBUG` to enable debug messages and write to
    `log`
- `lxc-attach -n test` gets a shell to the container
- `lxc-stop -n test` stops the container

## LXC Shells

- lxc-attach
  - `lxc_attach` calls `lxc_cmd_get_init_pid` to get the container's init pid,
    finds out the ns, openpty, and forks
  - the parent becomes the pty master
  - the child calls `lxc_attach_to_ns` to enter the ns, points
    stdin/stdout/stderr to the pty slave, and execs the shell
- lxc-console
  - lxc-start spawns and the child calls openpty multiple times.  lxc-start
    receives the master fds using `lxc_recv_ttys_from_child`
  - lxc-console requests one of the master fds

## LXC Networks

- by default, the container uses host net namespace
- to have its own net namespace,
  - edit `/var/lib/lxc/<container>/config`
    - `lxc.net.0.type = veth`
    - `lxc.net.0.link = lxcbr0`
    - `lxc.net.0.flags = up`
  - veth is a virtual ethernet device that always comes in pairs
    - one end in host
    - one end in container ns
- on the host, create a bridge
  - `ip link add name lxcbr0 type bridge`
  - `ip link set lxcbr0 up`
  - for wired host
    - `ip link set eth0 master lxcbr0`
  - for wireless host
    - `ip addr add 192.168.5.1/24 dev lxcbr0`
    - `sysctl net.ipv4.ip_forward=1`
    - `iptables -A POSTROUTING -t nat -j MASQUERADE`
    - optionally, start a DNS/DHCP server
      - `dnsmasq --conf-file= -a 192.168.5.1 -F 192.168.5.2,192.168.5.254`
- inside container
  - DHCP
  - or static
    - `ip addr add 192.168.5.2/24 dev eth0`
    - `ip route add default via 192.168.5.1 dev eth0`
- automatic host setup
  - create lxcbr0 bridge
    - create `/etc/default/lxc-net`
      - `USE_LXC_BRIDGE="true"`
    - `systemctl enable lxc-net`
    - it will create lxcbr0, run dnsmasq, and set up NAT
  - allow regular users to create veth pairs
    - create `/etc/lxc/lxc-usernet`
      - `<user> veth lxcbr0 4`

## LXC Mounts

- wayland socket
  - make sure container users have access to host `$XDG_RUNTIME_DIR/wayland-0`
    - including the socket and the all parent directories
  - add `lxc.mount.entry = /run/user/1000/wayland-0 mnt/wayland-0 none bind,create=file`
    - mount to /mnt becuase systemd over-mounts tmpfs to /run after the bind mount
  - in the container, try `XDG_RUNTIME_DIR=/mnt WAYLAND_DISPLAY=wayland-0 weston-flower`

## Unprivileged Containers

- use new user namespace
  - container config should have
    - `lxc.idmap = u 0 100000 65536`
    - `lxc.idmap = g 0 100000 65536`
  - this invokes `newuidmap` and `newgidmap` to map [100000-165536] in parent
    namespace to [0-65536] in new namespace
  - for `newuidmap` and `newgidmap` to work, update /etc/sub{uid,gid} to
    something like
    - format: `<user>:<first-uid>:<count>`
    - example: `root:100000:65536` or `olv:100000:65536`
- network
  - `lxc.net.0.type = none` inherits host network and does not work
    - mounting sysfs results in permission deny because kernel requires
      `CLONE_NEWNET` as well
  - `lxc.net.0.type = empty` works
    - but no network
  - `lxc.net.0.type = veth` works
    - but require setup
- this is enough to start unprivileged containers as root
- to start as a regular user,
  - copy `/etc/lxc/default.conf` to `~/.config/lxc/default.confg`
  - update `/etc/pam.d/system-login` or `/etc/pam.d/common-session`
    - `session    optional   pam_cgfs.so -c freezer,memory,name=systemd,unified`
    - not needed with pure cgroup v2?
  - `chmod o+x $HOME`

## Incus

- <https://github.com/lxc/incus>
  - forked from <https://github.com/canonical/lxd.git>, which provides `lxc`
    command instead of `incus` command
- setup
- `incus admin init` inits incus under `/var/lib/incus`
- `incus remote list` lists remote servers
  - `images` is the official image server
- `incus image list images:` lists images on `images:`
- `incus create images:alpine/edge test` creates instace `test` from
  `images:alpine/edge` image
- `incus list` lists instances
- `incus info <instance>` shows info about an instance
- `incus config show <instance>` shows config of an instance
- `incus start <instance>` starts an instance
- `incus stop <instance>` stops an instance
- `incus delete <instance>` delete an instance
- `incus exec <instance> -- sh` execs `sh` from the instance
- `incus file` copies files between host/instance
