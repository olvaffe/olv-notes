# Overview

 - qemu provides a virtio-gpu device
   - interface defined in kernel include/uapi/linux/virtio_gpu.h
   - bit VIRTIO_GPU_F_VIRGL decides whether the device supports virgl (3D accel)
   - it is advertised when qemu is compiled with virglrenderer support
 - kernel provides virtio-gpu driver
 - Mesa provides userspace virtio-gpu driver
 - Xorg uses glamor driver
   - uses EGL/GL/GBM
 - 3D buffer allocation
   - userspace does ioctl(DRM_IOCTL_VIRTGPU_RESOURCE_CREATE)
   - kernel sends VIRTIO_GPU_CMD_RESOURCE_CREATE_3D to device
   - qemu calls virgl_renderer_resource_create
   - virglrenderer calls glGenBuffers and glBufferData
 - 3D command buffer
   - opcodes defined in mesa src/gallium/drivers/virgl/virgl_protocol.h
   - mesa builds command buffers and ioctl(DRM_IOCTL_VIRTGPU_EXECBUFFER)
   - kernel sends VIRTIO_GPU_CMD_SUBMIT_3D to device
   - qemu calls virgl_renderer_submit_cmd
   - virglrenderer calls
     - glBlendColor when VIRGL_CCMD_SET_BLEND_COLOR
     - many more

# Memory Management

 - virtio_gpu_resource_create_ioctl
   - every virtio_gpu_object is created with a guest-managed unique
     hw_res_handle (id)
   - guest allocates pages
   - host is also requested to create backing storage (GL buffer)
   - guest calls RESOURCE_ATTACH_BACKING and host creates iovec over guest pages
 - DRM_IOCTL_VIRTGPU_TRANSFER_TO_HOST
   - host copies guest pages into GL buffer
 - DRM_IOCTL_VIRTGPU_TRANSFER_FROM_HOST
   - host copies GL buffer into guest pages
 - DRM_IOCTL_VIRTGPU_MAP
   - map guest pages
