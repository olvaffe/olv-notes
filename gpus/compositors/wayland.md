Wayland
=======

## Wayland core

- Binaries
  - `wayland-scanner` scans an Wayland protocol XML (`<name>.xml`) and outputs
    C code (`<name>-protocol.c`), client header (`<name>-client-protocol.h`),
    and server header (`<name>-server-protocol.h`).
  - `libwayland-server` is the core library for implementing a Wayland server
    - there is hand-written code whose header is `wayland-server-core.h`
    - there is scanner-generated code whose header is
      `wayland-server-protocol.h`
    - there is a copy of the util code whose header is `wayland-util.h`
  - `libwayland-client` is the core library for implementing a Wayland client
    - there is hand-written code whose header is `wayland-client-core.h`
    - there is scanner-generated code whose header is
      `wayland-client-protocol.h`
    - there is a copy of the util code whose header is `wayland-util.h`
  - `libwayland-cursor` is a helper to find and load Xcursor cursor images
    - only hand-written code whose header is `wayland-cursor.h`
  - `libwayland-egl` is a helper to create a `EGLNativeWindowType` for use
    with EGL
    - only hand-written code whose header is `wayland-egl.h`
    - there is also `wayland-egl-backend.h` used by EGL implementations to
      peek inside `wl_egl_window` and add hooks
- `libwayland-client`
  - basic
    - `wl_display` is the main object to connect to the server.  Internally, the
      connection is a `wl_connection` that wraps a socket fd with buffered io.
    - `wl_display` is also the proxy for a singleton object in the server
      exporting `wl_display` innterface
  - incoming event
    - Each incoming event targets a proxy.  It is read by the client from the
      socket fd, demarshalled to a `wl_closure`, and added to the
      `wl_event_queue` of the proxy
    - the client later dispatches closers in an event queue.  This invokes the
      corresponding method of the implementation for each closure
  - outgoing event
    - each outgoing event is generated by invoking a function of a proxy.  The
      regular function call is marshalled into a closure and written to the
      socket fd.
- `libwayland-server`
  - wayland protocols define many interfaces
  - a server supporting an interface can advertise it using a global
  - multiple server-side objects supporting the interface can be created
- `wl_connection` is an abstraction of the socket fd to the compositor
  - there are `in`/`out` and `fds_in`/`fds_out` buffers
  - calling `wl_connection_data` with `WL_CONNECTION_WRITABLE` writes `out` and
    `fds_out` buffers to the socket.  If all bytes are written, the `update`
    callback is called with `WL_CONNECTION_READABLE`, meaning that there is
    nothing in the connection to be written (because `WL_CONNECTION_WRITABLE` is
    no longer set).  It returns the number of bytes in the `in` buffer.
  - calling `wl_connection_data` with `WL_CONNECTION_READABLE` reads data from
    the socket and stores them in `in` and `fds_in` buffers.
  - In `wl_connection_write`, data are put on the `out` buffer.
    `wl_connection_data` is called only when the buffer is full.  If the
    connection was empty, the `update` callback is called with both
    `WL_CONNECTION_WRITABLE` and `WL_CONNECTION_READABLE` set, meaning there are
    data to be written and read.
- See also `mesa-wayland`

## Deep look at simple-shm

- Connect to display
  - `wl_display_connect(name)` connects to the named socket, or `wayland-0` if
    `NULL` is given.  `wl_display` is returned.  Internally,
    - `wl_connection_create(fd, ...)` is called to create a `wl_connection` for
      the socket fd
  - `wl_display_add_global_listener` add a callback to be invoked on each global
    objects
  - `wl_display_iterate` is called to read inbound data

## Rendering Models

- a `wl_surface` is a rectangular area that receives inputs and presents
  `wl_buffer`
  - many surface states are double-buffered;
  - protocol requests change the pending states
  - `wl_surface_commit` atomically makes all pending states current
    - the values of the pending states after commit are case by case
      - pending damage state becomes empty
      - pending scale state is unchanged
  - `wl_surface_attach` attaches a `wl_buffer` to a `wl_surface`
  - `wl_surface_frame` returns a `wl_callback` that is used to notify frame
    presented
- a `wl_buffer` is a content-provider for a `wl_surface`.  It is created from
  factory interfaces and can be attached to surfaces.
  - `release` event is used to notify that the buffer is released by the
    server and can be reused for other purposes (e.g., draw next frame)
- `wl_shm`
  - client allocates a shmem
    - client can access any area of the shmem
  - `wl_shm_create_pool` creates a `wl_shm_pool` from the shmem fd
    - server is granted access any area of the shmem
  - client suballocates from the shmem and call `wl_shm_pool_create_buffer`
    - client and server both know which area is used as the storage of the
      `wl_buffer`
- `wl_drm`
  - interface defined by Mesa, not Wayland
  - client allocates a GPU BO and export dmabuf
    - client can render to BO
  - `wl_drm_create_prime_buffer` to create a buffer from the dmabuf
    - server can sample from BO
  - originally, flink is used instead of dmabuf
- `zwp_linux_dmabuf_v1`
  - it is similar to `wl_drm` but with multi-planar and modifier support

## Xwayland

- without glamor, `wl_shm` is used
- with glamor, `wl_drm` and/or `zwp_linux_dmabuf_v1` are used
- when xwayland flips in `xwl_present_flip`, it calls
  - `wl_surface_attach` to attach the new dma-buf
  - `wl_surface_frame` to request a frame callback
  - `wl_surface_damage_buffer` to damage
  - `wl_surface_commit` to commit
  - `wl_display_flush` to flush
  - after a while, the frame callback is received
    - this happens when wayland is ready for another `wl_surface_commit`
    - xwayland calls `xwl_present_frame_callback` to send
      `PresentCompleteNotify` to the client and to execute another flip

## How does a client work

- Render with SHM
  - `display = wl_display_connect(NULL)` to connecto to the server and return
    `wl_display`
  - Listen for `wl_compositor` global and create `wl_compositor`
  - `surface = wl_compositor_create_surface(compositor)` to create `wl_surface`
  - an SHM buffer is created and an SHM-based `wl_buffer` is created with
    `buf = wl_shm_create_buffer(shm, fd, w, h, stride, vis)`
  - the SHM buffer is mapped for direct rendering
  - `wl_buffer_damage` is called to notify the buffer contents need revalidation
  - `wl_surface_attach` to attach the buffer to the surface
  - `wl_surface_damage` to notify the surface needs revalidation
- Render with EGL
  - `egldpy = eglGetDisplay(display)` to return the `EGLDisplay` of the
    `wl_display`
  - `native = wl_egl_window_create(surface)` to create the EGL native window
    from the `wl_surface`
  - `egl_surface = eglCreateWindowSurface(...)` to create the `EGLSurface` from
    the EGL native window
  - `eglMakeCurrent` and start rendering
  - after rendering a frame, `eglSwapBuffers` is called to present
- Render to pixmap (not used anywhere)
  - similar to rendering with SHM, except
  - A native pixmap is created instead of a SHM buffer
    - `pix = wl_egl_pixmap_create(w, h, vis, 0)`
  - `egl_surface = eglCreatePixmapSurface(...)` is called so that GL instead of
    CPU can be used for rendering 
    - `eglMakeCurrent` should work
    - `img = eglCreateImageKHR(..., EGL_NATIVE_PIXMAP_KHR, pix, NULL)`,
      `glEGLImageTargetTexture2DOES`, and render-to-texture should work too,
      without context switching
  - `wl_egl_pixmap_create_buffer` is called instead of `wl_shm_create_buffer`
    for presenting
- Render with cairo
  - the key is how the `cairo_surface_t` is created
    - SHM buffer and `cairo_image_surface_create_for_data` for CPU rendering
    - Pixmap and `cairo_gl_surface_create_for_texture` for GPU rendering
      - require `EGL_KHR_image_pixmap`
    - `wl_surface` and `cairo_gl_surface_create_for_egl` for GPU rendering
- More hints
  - after a buffer is attached to a surface, the buffer is owned by the
    compositor until the `release` event is received
  - if the compositor never sends the `release` event, clients will allocate a
    new buffer for each frame
  - a buffer may be attached to multiple surfaces
    - how does the `release` event work?

## How does a compositor work

- `wl_surface`
  - a surface has a texture object
  - when a buffer attached, the data are downloaded to the texture object
  - when a buffer is damaged, its data are re-downloaded
  - for DRM-based buffer, there is zero copy.
  - DRM-based buffers are not supported by core, but by mesa.  It is an internal
    mechanism

## mesa

- `libwayland-drm` defines `wl_drm` interface that is for internal use
  - when a client connects, `wl_drm` advertises the DRM device name
  - `authenticate` can be used to auth a DRM fd
  - `create_buffer` can be used to create a `wl_buffer` for the named bo
- `EGL_WL_bind_wayland_display` is used by EGL-based Wayland servers to run on
  an alternative window system.
  - It allows a server `wl_display` to be bound to an `EGLDisplay` for the
    alternative window system.
  - It allows an `EGLImageKHR` to be created from a `wl_buffer`
  - It adds `wl_drm` interface to the `wl_display`.
    - DRM device name is from the alternative window system
    - `authenticate` is implemented using the alternative window system
    - `create_buffer` creates a `__DRIimage` from the named bo
- Client EGL support
  - The color buffers of an `EGLSurface` are allocated by the DRI driver.
  - For each color buffer, there is an associated `wl_buffer` created using
    `wl_drm` interface
