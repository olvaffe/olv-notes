Mesa PanVK
==========

## Meson

- `panvk_entrypoints` generates
  - `panvk_instance_entrypoints`
  - `panvk_physical_device_entrypoints`
  - `panvk_device_entrypoints`
  - `panvk_v6_device_entrypoints`
  - `panvk_v7_device_entrypoints`
  - `panvk_v9_device_entrypoints`
  - `panvk_v10_device_entrypoints`
  - the idea is that, for device entrypoints, it dispatches to `vk_vX_Foo` if
    defined and falls back to `vk_Foo` if not
- `panvk_per_arch_libs` are per-arch static libraries
  - the source files are
    - `common_per_arch_files` (`panvk_vX_*.c`)
    - `bifrost_files` (`bifrost/*.c`) if v7 or older
    - `valhall_files` (`valhall/*.c`) if v9 or newer
    - `jm_files` (`jm/*.c`) if v9 or older
    - `csf_files` (`csf/*.c`) if v10+
  - `PAN_ARCH` is defined per-arch
- `libvulkan_panfrost` is the final shared library
  - `libpanvk_files` consists of non-per-arch `panvk_*.c`
- depenencies
  - `idep_pan_packers`, packet packers generated by genxml
  - `libpanfrost_shared`, helpers shared between panvk, panfrost, and lima
  - `libpanfrost_midgard`, midgard (v5 or older) compiler
  - `libpanfrost_bifrost`, bifrost (v6 or newer) compiler
  - `libpanfrost_decode`, packet decoder generated by genxml
  - `libpanfrost_lib`, helpers shared between panvk and panfrost
  - `libpanfrost_util`, helpers shared between bifrost and midgard compilers

## Environment Variables

- `PAN_I_WANT_A_BROKEN_VULKAN_DRIVER` is required to use panvk
- `PANVK_DEBUG` is parsed by `panvk_debug_options`
  - `startup` prints init info
  - `nir` dumps lowered nir before passing it to the backend compiler
  - `sync` waits for all submits
  - `trace` implies `sync` and dumps all submits
  - `afbc` allows AFBC
  - `linear` forces linear tiling
  - `dump` dumps vk memory contents on submits
  - `no_known_warn` is JM (job manager) only
- `PANDECODE_DUMP_FILE` defaults to `pandecode.dump`
- `BIFROST_MESA_DEBUG` is for the bifrost compiler
- `MIDGARD_MESA_DEBUG` is for the midgard compiler

## `pan_kmod_ops`

- `panthor_kmod_dev_create`
  - each `panvk_physical_device` and each `panvk_device` own a `pan_kmod_dev`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- `panthor_kmod_dev_destroy`
- `panthor_dev_query_props`
- `panthor_kmod_dev_query_user_va_range`
  - `panvk_device` uses this to decide the user va region
- `panthor_kmod_bo_alloc`
  - each `panvk_queue` has a bo as the ring buffer
  - `panvk_priv_bo_create` calls this for panvk-internal bos
  - each `panvk_device_memory` has a bo, either allocated or imported
  - `DRM_IOCTL_PANTHOR_BO_CREATE`
- `panthor_kmod_bo_free`
- `panthor_kmod_bo_import`
- `panthor_kmod_bo_export`
- `panthor_kmod_bo_get_mmap_offset`
  - `DRM_IOCTL_PANTHOR_BO_MMAP_OFFSET`
- `panthor_kmod_bo_wait`
  - panvk does not need this
- `panthor_kmod_vm_create`
  - each `panvk_device` has a vm
  - `DRM_IOCTL_PANTHOR_VM_CREATE`
- `panthor_kmod_vm_destroy`
  - `DRM_IOCTL_PANTHOR_VM_DESTROY`
- `panthor_kmod_vm_bind`
  - all bos must be bound to a device vm before they can be accessed by hw
  - `DRM_IOCTL_PANTHOR_VM_BIND`
- `panthor_kmod_vm_query_state`
  - panvk does not use this yet; query for faulty vm
  - `DRM_IOCTL_PANTHOR_VM_GET_STATE`
- `panthor_kmod_query_timestamp`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- some ioctls are not abstracted
- `panvk_per_arch(queue_init)`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE`
  - `DRM_IOCTL_PANTHOR_GROUP_CREATE`
    - `drm_panthor_group_create`
      - it can control which cores a draw or a dispatch runs on
      - `priority` decides the priority
      - `queues` uses 3 queues
        - `PANVK_SUBQUEUE_VERTEX_TILER`
        - `PANVK_SUBQUEUE_FRAGMENT`
        - `PANVK_SUBQUEUE_COMPUTE`
- `panvk_per_arch(queue_finish)`
  - `DRM_IOCTL_PANTHOR_GROUP_DESTROY`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_DESTROY`
- `panvk_queue_submit`
  - `DRM_IOCTL_PANTHOR_GROUP_SUBMIT`
- query device lost
  - `DRM_IOCTL_PANTHOR_GROUP_GET_STATE`

## Command Stream

- `genxml/v10.xml`
  - CS aka CEU (Command Execution Unit)
  - 7 cs enums
    - `CS Condition`
    - `CS State`
    - `CS Heap Operation`
    - `CS Flush Mode`
    - `CS Sync scope`
    - `CS Exception type`
    - `CS Opcode`
  - 40 cs structs
    - `pandecode_cs` is a good place to know how they work
      - `interpret_ceu_instr`
      - `disassemble_ceu_instr`
    - all structs have size 2 (dwords)
    - `CS Base` is not a real opcode
      - it is only used by the decoder
      - bit 0..55: op payload
      - bit 56..63: op code
    - `CS NOP` is nop
      - the payload is ignored
    - `CS MOVE` does `dst_reg = imm48`
    - `CS MOVE32` does `dst_reg = imm32`
    - `CS WAIT` waits the specified slots (scoreboards?)
      - the fw supports `scoreboard_slot_count` slots
      - userspace can decide which is for what
      - `PANVK_SB_LS`, load/store
      - `PANVK_SB_IMM_FLUSH`,
      - `PANVK_SB_DEFERRED_SYNC`
      - `PANVK_SB_DEFERRED_FLUSH`
      - `PANVK_SB_ITER_START`
      - `PANVK_SB_ITER_COUNT`
    - `CS RUN_COMPUTE` runs a compute job
      - it expects reg0..reg39 to be set up, such as
        - reg0 points to res table
        - reg8 points to push consts
        - reg16 points to shader
        - reg24 points to local storage
        - reg32 is global attr offset
        - reg33 is wg size
        - reg34..36 are wg offsets
        - reg37..39 are wg counts
    - `CS RUN_TILING` runs a tiling job, unused?
    - `CS RUN_IDVS` runs an idvs (index-driven vs) job
      - traditional vs: vertex shading -> primitive assembly -> culling
        - wasted computation if a primitive is culled
      - idvs since bifrost: primitive assembly -> position shading -> culling -> varying shading
    - `CS RUN_FRAGMENT` runs an fs job
    - `CS RUN_FULLSCREEN` runs a fullscreen job
    - `CS FINISH_TILING`
    - `CS FINISH_FRAGMENT`
    - `CS ADD_IMMEDIATE32` does `dst_reg = src_reg + imm32`
    - `CS ADD_IMMEDIATE64` does `dst_reg64 = src_reg64 + imm32`
    - `CS UMIN32` does `dst_reg = min(src_reg1, src_reg2)`
    - `CS LOAD_MULTIPLE` does `dst_reg = load(src_reg + imm16)`
    - `CS STORE_MULTIPLE` does `store(src_reg1 + imm16, src_reg2)`
    - `CS BRANCH` jumps a signed imm16 offset if the reg meets the condition
    - `CS SET_SB_ENTRY`
    - `CS PROGRESS_WAIT` is unused
    - `CS SET_EXCEPTION_HANDLER` is unused
    - `CS CALL` calls `(reg1, reg2)`
      - `reg1` is the addr
      - `reg2` is the length
    - `CS JUMP` jumps to `(reg1, reg2)`
      - why does it need the length?
    - `CS REQ_RESOURCE` is needed before/after running a job
      - it requests and releases the needed res?
    - `CS FLUSH_CACHE2` flushes L2 and LSC caches
      - this is used for barriers
    - `CS SYNC_ADD32`  does `store(addr, load(addr) + src_reg)` after sync
    - `CS SYNC_SET32` does `store(addr, src_reg)` after sync
    - `CS SYNC_WAIT32` busy-waits until an `load(addr)` meets the condition
    - `CS STORE_STATE` does `store(src_reg + imm16, state)`, where `state` is
      - `MALI_CS_STATE_TIMESTAMP`
      - `MALI_CS_STATE_CYCLE_COUNT`
      - `MALI_CS_STATE_DISJOINT_COUNT`
      - `MALI_CS_STATE_ERROR_STATUS`
    - `CS PROT_REGION` is unused
    - `CS PROGRESS_STORE` is unused
    - `CS PROGRESS_LOAD` is unused
    - `CS RUN_COMPUTE_INDIRECT` runs a compute job
    - `CS ERROR_BARRIER` is unused
    - `CS HEAP_SET` sets the heap va
    - `CS HEAP_OPERATION`
    - `CS TRACE_POINT` is unused
    - `CS SYNC_ADD64`
    - `CS SYNC_SET64`
    - `CS SYNC_WAIT64`
- `cs_scratch_reg32` returns a `cs_index`
  - it checks that the reg is in `PANVK_CS_REG_SCRATCH_{START,END}`
  - `cs_reg_tuple` builds the `cs_index` struct
  - there is a total of `b->conf.nr_registers - b->conf.nr_kernel_registers`
    registers
- `cs_move32_to`
  - `cs_alloc_ins` returns a ptr to an instr
    - the ptr points to an offset in `b->cur_chunk.buffer.cpu` which is u64
  - `pan_pack` expands to
    - `struct MALI_CS_MOVE32 I = { MALI_CS_MOVE32_header }`
    - custom code to modify `I`
    - `MALI_CS_MOVE32_pack(ptr, &I)`
  - `cs_dst32` converts a `cs_index` into a u8, the raw reg number
- panvk-specific helpers
  - `panvk_cs_reg_whitelist` is a macro to define a `reg_perm_cb_t`
    - it validates that the regs being written are on the whitelist
  - `cs_update_progress_seqno(b) { foo }` validates that foo only writes to
    seqno regs (84..89)
    - 2 regs per subqueue
    - `PANVK_SUBQUEUE_VERTEX_TILER` uses 84 and 85
    - `PANVK_SUBQUEUE_FRAGMENT` uses 86 and 87
    - `PANVK_SUBQUEUE_COMPUTE` uses 88 and 89
  - `cs_update_compute_ctx(b) { foo }` validates that foo only writes to
    compute regs (0..39)
  - `cs_update_frag_ctx(b) { foo }` validates that foo only writes to
    frag regs (40..46)
  - `cs_update_vt_ctx(b) { foo }` validates that foo only writes to
    vertex tiler / idvs regs (0..60)

## Command Stream Decoder

- usage
  - `pandecode_create_context` and `pandecode_destroy_context` are called
    per-VkDevice
  - `pandecode_inject_mmap` and `pandecode_inject_free` are called per-BO
    - `ctx->mmap_tree` manages the BOs
  - these are called per-queue-submit
    - `pandecode_dump_file_open` opens the file
      - optional because `pandecode_cs` and `pandecode_dump_mappings` (but not
        `pandecode_log`) open on-demand
    - `pandecode_log` printfs to the file
    - `pandecode_cs` decodes a command stream
    - `pandecode_dump_mappings` dumps the contents of BOs
    - `pandecode_next_frame` closes the file
- `pandecode_cs` calls `GENX(pandecode_cs)`
  - `regs` is an array of 256 u32, initialized to 0, on stack
  - `pandecode_find_mapped_gpu_mem_containing` finds the BO containing the cs
    - it also `mprotect` the BO and adds it to `ctx->ro_mappings`
    - at the end of decode, `pandecode_map_read_write` undoes the `mprotect`
  - `disassemble_ceu_instr` prints the u64 instr
  - `interpret_ceu_instr` simulates the u64 instr

## Command Buffer

- a `panvk_cmd_buffer` has
  - a `panvk_cmd_graphics_state`
  - a `panvk_cmd_compute_state`
  - a `panvk_push_constant_state`
    - this is user push consts
    - sysvals are also pushed on top of user push consts
  - a per-subqueue `panvk_cs_state`
  - a `panvk_tls_state`
    - tls is for shader reg spills, etc.
