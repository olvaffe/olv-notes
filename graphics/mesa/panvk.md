Mesa PanVK
==========

## Meson

- `panvk_entrypoints` generates
  - `panvk_instance_entrypoints`
  - `panvk_physical_device_entrypoints`
  - `panvk_device_entrypoints`
  - `panvk_v6_device_entrypoints`
  - `panvk_v7_device_entrypoints`
  - `panvk_v9_device_entrypoints`
  - `panvk_v10_device_entrypoints`
  - the idea is that, for device entrypoints, it dispatches to `vk_vX_Foo` if
    defined and falls back to `vk_Foo` if not
- `panvk_per_arch_libs` are per-arch static libraries
  - the source files are
    - `common_per_arch_files` (`panvk_vX_*.c`)
    - `bifrost_files` (`bifrost/*.c`) if v7 or older
    - `valhall_files` (`valhall/*.c`) if v9 or newer
    - `jm_files` (`jm/*.c`) if v9 or older
    - `csf_files` (`csf/*.c`) if v10+
  - `PAN_ARCH` is defined per-arch
- `libvulkan_panfrost` is the final shared library
  - `libpanvk_files` consists of non-per-arch `panvk_*.c`
- depenencies
  - `idep_pan_packers`, packet packers generated by genxml
  - `libpanfrost_shared`, helpers shared between panvk, panfrost, and lima
  - `libpanfrost_midgard`, midgard (v5 or older) compiler
  - `libpanfrost_bifrost`, bifrost (v6 or newer) compiler
  - `libpanfrost_decode`, packet decoder generated by genxml
  - `libpanfrost_lib`, helpers shared between panvk and panfrost
  - `libpanfrost_util`, helpers shared between bifrost and midgard compilers

## Environment Variables

- `PAN_I_WANT_A_BROKEN_VULKAN_DRIVER` is required to use panvk
- `PANVK_DEBUG` is parsed by `panvk_debug_options`
  - `startup` prints init info
  - `nir` dumps lowered nir before passing it to the backend compiler
  - `sync` waits for all submits
  - `trace` implies `sync` and dumps all submits
  - `afbc` allows AFBC
  - `linear` forces linear tiling
  - `dump` dumps vk memory contents on submits
  - `no_known_warn` is JM (job manager) only
- `PANDECODE_DUMP_FILE` defaults to `pandecode.dump`
- `BIFROST_MESA_DEBUG` is for the bifrost compiler
- `MIDGARD_MESA_DEBUG` is for the midgard compiler

## `pan_kmod_ops`

- `panthor_kmod_dev_create`
  - each `panvk_physical_device` and each `panvk_device` own a `pan_kmod_dev`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- `panthor_kmod_dev_destroy`
- `panthor_dev_query_props`
- `panthor_kmod_dev_query_user_va_range`
  - `panvk_device` uses this to decide the user va region
- `panthor_kmod_bo_alloc`
  - each `panvk_queue` has a bo as the ring buffer
  - `panvk_priv_bo_create` calls this for panvk-internal bos
  - each `panvk_device_memory` has a bo, either allocated or imported
  - `DRM_IOCTL_PANTHOR_BO_CREATE`
- `panthor_kmod_bo_free`
- `panthor_kmod_bo_import`
- `panthor_kmod_bo_export`
- `panthor_kmod_bo_get_mmap_offset`
  - `DRM_IOCTL_PANTHOR_BO_MMAP_OFFSET`
- `panthor_kmod_bo_wait`
  - panvk does not need this
- `panthor_kmod_vm_create`
  - each `panvk_device` has a vm
  - `DRM_IOCTL_PANTHOR_VM_CREATE`
- `panthor_kmod_vm_destroy`
  - `DRM_IOCTL_PANTHOR_VM_DESTROY`
- `panthor_kmod_vm_bind`
  - all bos must be bound to a device vm before they can be accessed by hw
  - `DRM_IOCTL_PANTHOR_VM_BIND`
- `panthor_kmod_vm_query_state`
  - panvk does not use this yet; query for faulty vm
  - `DRM_IOCTL_PANTHOR_VM_GET_STATE`
- `panthor_kmod_query_timestamp`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- some ioctls are not abstracted
- `panvk_per_arch(queue_init)`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE`
  - `DRM_IOCTL_PANTHOR_GROUP_CREATE`
    - `drm_panthor_group_create`
      - it can control which cores a draw or a dispatch runs on
      - `priority` decides the priority
      - `queues` uses 3 queues
        - `PANVK_SUBQUEUE_VERTEX_TILER`
        - `PANVK_SUBQUEUE_FRAGMENT`
        - `PANVK_SUBQUEUE_COMPUTE`
- `panvk_per_arch(queue_finish)`
  - `DRM_IOCTL_PANTHOR_GROUP_DESTROY`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_DESTROY`
- `panvk_queue_submit`
  - `DRM_IOCTL_PANTHOR_GROUP_SUBMIT`
- query device lost
  - `DRM_IOCTL_PANTHOR_GROUP_GET_STATE`

## Command Stream

- `cs_scratch_reg32` returns a `cs_index`
  - it checks that the reg is in `PANVK_CS_REG_SCRATCH_{START,END}`
  - `cs_reg_tuple` builds the `cs_index` struct
  - there is a total of `b->conf.nr_registers - b->conf.nr_kernel_registers`
    registers
- `cs_move32_to`
  - `cs_alloc_ins` returns a ptr to an instr
    - the ptr points to an offset in `b->cur_chunk.buffer.cpu` which is u64
  - `pan_pack` expands to
    - `struct MALI_CS_MOVE32 I = { MALI_CS_MOVE32_header }`
    - custom code to modify `I`
    - `MALI_CS_MOVE32_pack(ptr, &I)`
  - `cs_dst32` converts a `cs_index` into a u8, the raw reg number
