Mesa PanVK
==========

## Meson

- `panvk_entrypoints` generates
  - `panvk_instance_entrypoints`
  - `panvk_physical_device_entrypoints`
  - `panvk_device_entrypoints`
  - `panvk_v6_device_entrypoints`
  - `panvk_v7_device_entrypoints`
  - `panvk_v9_device_entrypoints`
  - `panvk_v10_device_entrypoints`
  - the idea is that, for device entrypoints, it dispatches to `vk_vX_Foo` if
    defined and falls back to `vk_Foo` if not
- `panvk_per_arch_libs` are per-arch static libraries
  - the source files are
    - `common_per_arch_files` (`panvk_vX_*.c`)
    - `bifrost_files` (`bifrost/*.c`) if v7 or older
    - `valhall_files` (`valhall/*.c`) if v9 or newer
    - `jm_files` (`jm/*.c`) if v9 or older
    - `csf_files` (`csf/*.c`) if v10+
  - `PAN_ARCH` is defined per-arch
- `libvulkan_panfrost` is the final shared library
  - `libpanvk_files` consists of non-per-arch `panvk_*.c`
- depenencies
  - `idep_pan_packers`, packet packers generated by genxml
  - `libpanfrost_shared`, helpers shared between panvk, panfrost, and lima
  - `libpanfrost_midgard`, midgard (v5 or older) compiler
  - `libpanfrost_bifrost`, bifrost (v6 or newer) compiler
  - `libpanfrost_decode`, packet decoder generated by genxml
  - `libpanfrost_lib`, helpers shared between panvk and panfrost
  - `libpanfrost_util`, helpers shared between bifrost and midgard compilers

## Environment Variables

- `PAN_I_WANT_A_BROKEN_VULKAN_DRIVER` is required to use panvk
- `PANVK_DEBUG` is parsed by `panvk_debug_options`
  - `startup` prints init info
  - `nir` dumps lowered nir before passing it to the backend compiler
  - `sync` waits for all submits
  - `trace` implies `sync` and dumps all submits
  - `afbc` allows AFBC
  - `linear` forces linear tiling
  - `dump` dumps vk memory contents on submits
  - `no_known_warn` is JM (job manager) only
- `PANDECODE_DUMP_FILE` defaults to `pandecode.dump`
- `BIFROST_MESA_DEBUG` is for the bifrost compiler
- `MIDGARD_MESA_DEBUG` is for the midgard compiler

## `pan_kmod_ops`

- `panthor_kmod_dev_create`
  - each `panvk_physical_device` and each `panvk_device` own a `pan_kmod_dev`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- `panthor_kmod_dev_destroy`
- `panthor_dev_query_props`
- `panthor_kmod_dev_query_user_va_range`
  - `panvk_device` uses this to decide the user va region
- `panthor_kmod_bo_alloc`
  - each `panvk_queue` has a bo as the ring buffer
  - `panvk_priv_bo_create` calls this for panvk-internal bos
  - each `panvk_device_memory` has a bo, either allocated or imported
  - `DRM_IOCTL_PANTHOR_BO_CREATE`
- `panthor_kmod_bo_free`
- `panthor_kmod_bo_import`
- `panthor_kmod_bo_export`
- `panthor_kmod_bo_get_mmap_offset`
  - `DRM_IOCTL_PANTHOR_BO_MMAP_OFFSET`
- `panthor_kmod_bo_wait`
  - panvk does not need this
- `panthor_kmod_vm_create`
  - each `panvk_device` has a vm
  - `DRM_IOCTL_PANTHOR_VM_CREATE`
- `panthor_kmod_vm_destroy`
  - `DRM_IOCTL_PANTHOR_VM_DESTROY`
- `panthor_kmod_vm_bind`
  - all bos must be bound to a device vm before they can be accessed by hw
  - `DRM_IOCTL_PANTHOR_VM_BIND`
- `panthor_kmod_vm_query_state`
  - panvk does not use this yet; query for faulty vm
  - `DRM_IOCTL_PANTHOR_VM_GET_STATE`
- `panthor_kmod_query_timestamp`
  - `DRM_IOCTL_PANTHOR_DEV_QUERY`
- some ioctls are not abstracted
- `panvk_per_arch(queue_init)`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_CREATE`
  - `DRM_IOCTL_PANTHOR_GROUP_CREATE`
    - `drm_panthor_group_create`
      - it can control which cores a draw or a dispatch runs on
      - `priority` decides the priority
      - `queues` uses 3 queues
        - `PANVK_SUBQUEUE_VERTEX_TILER`
        - `PANVK_SUBQUEUE_FRAGMENT`
        - `PANVK_SUBQUEUE_COMPUTE`
- `panvk_per_arch(queue_finish)`
  - `DRM_IOCTL_PANTHOR_GROUP_DESTROY`
  - `DRM_IOCTL_PANTHOR_TILER_HEAP_DESTROY`
- `panvk_queue_submit`
  - `DRM_IOCTL_PANTHOR_GROUP_SUBMIT`
- query device lost
  - `DRM_IOCTL_PANTHOR_GROUP_GET_STATE`

## Command Stream

- `genxml/v10.xml`
  - CS aka CEU (Command Execution Unit)
  - 7 cs enums
    - `CS Condition`
    - `CS State`
    - `CS Heap Operation`
    - `CS Flush Mode`
    - `CS Sync scope`
    - `CS Exception type`
    - `CS Opcode`
  - 40 cs structs
    - all structs have size 2 (dwords)
    - `CS Base` is not a real opcode
      - it is only used by the decoder
      - bit 0..55: op payload
      - bit 56..63: op code
    - `CS NOP` is nop
      - the payload is ignored
    - `CS MOVE` does `dst_reg = imm48`
    - `CS MOVE32` does `dst_reg = imm32`
    - `CS WAIT` waits the specified slots (scoreboards?)
      - `PANVK_SB_LS`, load/store
      - `PANVK_SB_IMM_FLUSH`,
      - `PANVK_SB_DEFERRED_SYNC`
      - `PANVK_SB_DEFERRED_FLUSH`
      - `PANVK_SB_ITER_START`
      - `PANVK_SB_ITER_COUNT`
    - `CS RUN_COMPUTE` runs a compute job
    - `CS RUN_TILING` runs a tiling job, unused?
    - `CS RUN_IDVS` runs an idvs (index-driven vs) job
      - traditional vs: vertex shading -> primitive assembly -> culling
        - wasted computation if a primitive is culled
      - idvs since bifrost: primitive assembly -> position shading -> culling -> varying shading
    - `CS RUN_FRAGMENT` runs an fs job
    - `CS RUN_FULLSCREEN` runs a fullscreen job
    - `CS FINISH_TILING`
    - `CS FINISH_FRAGMENT`
    - `CS ADD_IMMEDIATE32` does `dst_reg = src_reg + imm32`
    - `CS ADD_IMMEDIATE64` does `dst_reg64 = src_reg64 + imm32`
    - `CS UMIN32` does `dst_reg = min(src_reg1, src_reg2)`
    - `CS LOAD_MULTIPLE`
    - `CS STORE_MULTIPLE`
    - `CS BRANCH`
    - `CS SET_SB_ENTRY`
    - `CS PROGRESS_WAIT`
    - `CS SET_EXCEPTION_HANDLER`
    - `CS CALL`
    - `CS JUMP`
    - `CS REQ_RESOURCE`
    - `CS FLUSH_CACHE2`
    - `CS SYNC_ADD32`
    - `CS SYNC_SET32`
    - `CS SYNC_WAIT32`
    - `CS STORE_STATE`
    - `CS PROT_REGION`
    - `CS PROGRESS_STORE`
    - `CS PROGRESS_LOAD`
    - `CS RUN_COMPUTE_INDIRECT`
    - `CS ERROR_BARRIER`
    - `CS HEAP_SET`
    - `CS HEAP_OPERATION`
    - `CS TRACE_POINT`
    - `CS SYNC_ADD64`
    - `CS SYNC_SET64`
    - `CS SYNC_WAIT64`
- `cs_scratch_reg32` returns a `cs_index`
  - it checks that the reg is in `PANVK_CS_REG_SCRATCH_{START,END}`
  - `cs_reg_tuple` builds the `cs_index` struct
  - there is a total of `b->conf.nr_registers - b->conf.nr_kernel_registers`
    registers
- `cs_move32_to`
  - `cs_alloc_ins` returns a ptr to an instr
    - the ptr points to an offset in `b->cur_chunk.buffer.cpu` which is u64
  - `pan_pack` expands to
    - `struct MALI_CS_MOVE32 I = { MALI_CS_MOVE32_header }`
    - custom code to modify `I`
    - `MALI_CS_MOVE32_pack(ptr, &I)`
  - `cs_dst32` converts a `cs_index` into a u8, the raw reg number
