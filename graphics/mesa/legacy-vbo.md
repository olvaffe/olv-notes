Mesa and Its VBO Context
========================

## Dispatch

- `GLvertexformat` defines a subset of dispath table that includes `Begin`,
  `End`, and whatever is possible in them.  Finally, there is also `Array`.
  This is because a `Begin` and `End` pair produces an `Array`.
  - To make glapi dispatch to them, `_mesa_install_exec_vtxfmt` or
    `_mesa_install_save_vtxfmt` should be called.
  - exec one is a little different than save one in that it is lazily
    dispatched.  But this is the details not relevant here.
- In `_mesa_initialize_context`,
  - vtxfmt for exec is not initialized  (it is initialized to a neutral one, not
    a real one).
  - vtxfmt for save is initialized in `_mesa_init_display_list`.
    - `save_Xxxx` is used
- Normally, a driver would use vbo module `_vbo_CreateContext`
  - in `vbo_exec_vtx_init`, vtxfmt for exec is initialized.
    - `vbo_Xxx` is used
  - in `vbo_save_api_init`, another vtxfmt for save is initialized, but _not_
    installed.
    - This set of vtxfmt for save is installed when one of the `DrawXxx` or
      `Rectf` is called.  Or, when `glBegin` is called in list compiling through
      `Driver.NotifySaveBegin`.
    - `_save_Xxxx` is used
- It is worth to talk a little about ae, arrayelt, or `ArrayElement`
  - `glArrayElemnt` is equivalent to one of `glVertex`, `glColor`, etc. using
    the array object.
  - `api_arrayelt.c` is used to help determine which of the functions should be
    called.

## vbo Context

- In `install_vtxfmt`, per-vertex functions are set up to be dispatched to
  `vbo/`.
- `vbo_exec_Begin` (`glBegin`)
  - a begin/end pair defines a primitive.
  - `exec->vtx.prim_count` is increased
  - the primitive is recorded at `exec->vtx.prim[i]`.
  - the primitive's `start` is set to `exec->vtx.vert_count`.
- there is an array of `exec->vtx.vert_count` vertices.  They belong to an
  array of `exec->vtx.prim_count` primitives.
- vertices are stored in `exec->vtx.buffer_map`.  `exec->vtx.buffer_ptr` is a
  cursor to the buffer map.
- there are many sizes in `exec->vtx`
  - `attrsz[A]` is the size of attr A
  - `vertex_size` is the sum of attrsz over all attrs
  - since vertex are stored in buffer map, `max_vert` depends on `vertex_size`
    and buffer map size.
- active vertex
  - all modifications are made to the active vertex
  - it is not part of the vertices in the array
  - the storage of the active vertex is `exec->vtx.vertex`.  It has static
    size.  `exec->vtx.attrptr[A]` is the cursor.
  - `active_sz[A]` is the active size of attr A.  the size of each attr is
    dynamic.
  - when the attr to be set is `VBO_ATTRIB_POS`, active vertex is stored.  That
    is, `exec->vtx.buffer_ptr[i] = exec->vtx.vertex[i]` for each `i`.
    `exec->vtx.vert_count` is increased.
- all the modification functions are generated by `vbo_attrib_tmp.h`.
- `vbo_copy_vertices` copies the last, at most 3, vertices of the last primitive
  to `exec->vtx.copied`.  It is called before flushing, so that the status of
  the last few vertices is remembered.  It is more clear to see it being used in
  `vbo_exec_vtx_wrap`.
- `struct vbo_context` has a `struct gl_client_array` for each attr in its
  `currval`.  The `Ptr` of each client array points to `ctx->Current.Attrib[x]`.
  See `init_legacy_currval`.

## Buffer Management

- `exec->vtx.bufferobj` points to `ctx->Shared->NullBufferObj`, with
  `buffer_map` pointing to `malloc()`ed memory at first.
- (only) Gallium calls `vbo_use_buffer_objects` to use buffer objects.
- All `vbo->currval[]` uses `NullBufferObj`, with their `Ptr` pointing to
  `ctx->Current.Attrib`.
- In `vbo_exec_bind_arrays`, `exec->vtx.arrays[]` is updated to use
  `exec->vtx.bufferobj`.
- So, no, there is no buffer object when no gallium.
- But this is the case with `glBegin` and `glVertexPointer`.
  `GL_ARB_vertex_buffer_object` always uses buffer object.

## vertices and `Vertex`/`VertexPointer`/`VBO`

- Vertices are passed to `draw_prims` in the form of many `struct gl_client_array`.
  There is one such struct per attribute.  The struct has
  - `Size` to specify the number of coords per vertex.
  - `Type` to specify the storage type, int, float, etc.
  - `BufferObj` to specify the underlying buffer object.
  - `Ptr` to specify the VBO offset or location of client array, depending on
    whether `BufferObj` has a `Name`.  (The `Name` is a non-zero unique id).
  - some other fields...
- `struct vbo_exec_context` has two big members `vtx` and `array`.
  - They are for `glBegin` and vertex array repectively.
- `glVertex` stores the coordinates in `exec->vtx` temporary and are flushed to
  `draw_prims` directly.
  - The "many client arrays" are `exec->vtx.arrays`.  They share
    `exec->vtx.bufferobj` as their `BufferObj` and their `Ptr` point to
    `exec->vtx.buffer_map`.
  - `exec->vtx.inputs` is made pointing to the arrays and is passed to `draw_prims`.
  - See `vbo_exec_bind_arrays` in `vbo_exec_draw.c` or above.
- `glVertexPointer` and the related functions store the coordinates in
  `ctx->Array.ArrayObj`.
  - An array object has many client arrays.
  - Every client array references `ctx->Array.ArrayBufferObj` and has `Ptr`
    pointing to the client given pointer (no local storage).
  - See `_mesa_VertexPointer`.
  - Before drawing really happens, `exec->array.legacy_array` and
    `exec->array.generic_array` are made pointing to members of
    `ctx->Array.ArrayObj`.  `exec->array.inputs` then selects suitable arrays.
  - See `bind_arrays` in `vbo_exec_array.c`.
- VBO stores the given coordinates in `ctx->Array.ArrayBufferObj`.
  - It copies the coordinates into the object.  There is only one bufffer
    object.  Data of all client arrays (one for each attr, remember?) should be
    uploaded to the same buffer object to form a so called interfaced array.
  - It goes the same code path as vertex array does.  `glVertexPointer` and
    others now give offsets into the buffer object.
  - When drawing, since `GL_ARRAY_BUFFER_ARB` is bound, `Name` is non-zero and
    `Ptr` of client arrays are interpreted as offsets into the buffer object.

## `FLUSH_VERTICES`

- Vertices might be buffered in vbo.  Flushing means `draw_prims` and update the
  status from vbo to `ctx->Current`.  It calls driver's `FlushVertices`.
- If only vertex array or vertex buffer object is used, there is nothing to
  flush.  The code path is in `vbo_exec_array.c`.
- `vbo_exec_init` sets it to `vbo_exec_FlushVertices`.
- It calls `vbo_exec_vtx_flush` with `unmap` set to true.
  - `vbo_exec_bind_arrays` updates vertices in `exec->vtx` to another form in
    `exec->vtx.arrays`.  `exec->vtx.inputs` is set up to point to suitable
    arrays.
  - The buffer is unmapped and `draw_prims` is called.
- It calls `vbo_exec_copy_to_current` to copy active vertex to `vbo->currval`,
  which points to `ctx->Current.Attrib`.

## Arrays Passed to `draw_prims`

- There are six material attributes, and there are front and back for each one,
  in `ctx->Light.Material`.
- Indexing
  - `ctx->Current.Attrib` is indexed by `VERT_ATTRIB_XXX`, 16 conventional and
    16 generic attributes.
  - `vbo->exec.vtx.arrays` is indexed by `VBO_ATTRIB_XXX`, 32 conventional and
    generic attributes plus 12 material attrs.
  - See `_vbo_CreateContext` for `VERT_ATTRIB_XXX` to `VBO_ATTRIB_XXX` mapping.
    It depends on the program mode.
  - tnl uses `_TNL_ATTRIB_XXX`, 32 attributes, with material attrs aliasing
    first 12 generic ones.
- vbo context references current attributes in main context
  - `legacy_currval` wraps first 16 attr of `ctx->Current.Attrib`.
  - `generic_currval` wraps second 16 attr of `ctx->Current.Attrib`.
  - `map_currval` wraps `ctx->Light.Material`.
- vertex arrays are passed to `draw_prims` in `VERT_ATTRIB_XXX` order
  - That is, it needs to pass 32 arrays, which are supposed to be indexed by
    `VERT_ATTRIB_XXX`.  However, how tnl indexes them depends on the program
    mode.
  - In `vbo_exec_vtx_flush`,
    - For the first 16 arrays, `VP_NONE`, `VP_NV`, and `VP_ARB` all pass the
      first 16 attrs of `ctx->Current.Attrib`.
    - For the second 16 arrays,
      - `VP_NONE` passes 12 material attrs in `ctx->Light.Material`.
      - `VP_NV` and `VP_ARB` pass the second 16 attrs of `ctx->Current.Attrib`.
    - If any `glColor`, etc. are given, it overrides the above default values.
      See `vbo_exec_bind_arrays`.
  - In `glDrawArrays`,
    - For the first 16 arrays,
      - `VP_NONE` passes current VAO's conventional arrays
      - `VP_NV` passes current VAO's generic arrays
      - `VP_ARB` passes current VAO's conventional arrays, except that the first
        generic array overrides the first conventional arrays.
    - For the second 16 arrays,
      - `VP_NONE` passes 12 material attrs.
      - `VP_NV` passes nothing.
      - `VP_ARB` passes 16 generic arrays.
    - For fallbacks, see `recalculate_input_bindings`.

## Vertex Format

- Per-vertex functions are dispatched like
  - `glColor4fv` is dispatched to `neutral_Color4fv`.
  - `neutral_Xxx` does something and installs the real function from
    `ctx->TnlModule->Current` to the dispatch table.
  - It dispatches again to call the real function.
  - Next time, the function is directly dispatched.
  - The dispatch table is reset to `neutral` after `_mesa_restore_exec_vtxfmt`.
- per-vertex functions changes `ctx->Current`, current attributes, _indirectly_
- `glBegin` is dispatched to `vbo_exec_Begin`, which starts a new primitive.
- Before ending, some per-vertex functions are called
  - They are dispatched to neutral functions first.  The real functions
    installed are `vbo_Xxx`.  See `ATTR` and `vbo_attrib_tmp.h` in
    `vbo_exec_api.c`.
  - In neutral functions, the first time call would call
    `ctx->Driver.BeginVertices`.  `vbo_exec_BeginVertices` will set
    `FLUSH_UPDATE_CURRENT` to `NeedFlush`.  It means the vtxfmt should be
    restored to neutral ones(?).  See below.
  - As can be seen from `ATTR`, if `glVertex` is called, `FLUSH_STORED_VERTICES`
    is set to `NeedFlush`.
- `vbo_exec_End` ends the primitive begun by `glBegin`.
- `vbo_exec_FlushVertices` flushes buffered vertices by calling
  `vbo_exec_vtx_flush`.  It then copies the active state from execution context
  to `vbo->currval`, which points to `ctx->Current` in main context.
  `ctx->NewState` is updated accordingly.  If `FLUSH_UPDATE_CURRENT` is set,
  `_mesa_restore_exec_vtxfmt` is called.
- Semantically,
  - `FLUSH_VERTICES` flushes vertices and state buffered in `vbo`, if there is
    one or more vertices buffered.
    - `glVertex` gives vertices; Others like `glColor` gives states.
  - `FLUSH_CURRENT` flushes vertices and state bufferd in `vbo`, if the state of
    vbo execution context is different from the main context's.  There might be
    no vertices at all.
  - For example, `glPushAttrib` with `GL_CURRENT_BIT` would `FLUSH_CURRENT`
    before storing the current attrib.
  - `glBindTexture` would `FLUSH_VERTICES` before binding to the new texture.

