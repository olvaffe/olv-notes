Mesa and glapi
==============

## mesa/glapi/

- very lowlevel, usually not called directly
- gl_apitemp.h is generated by gl_apitemp.py, in charge of defining entry points.
  NAME: define all NAMEXXXX (imagine NAME==gl) functions, using DISPATCH
  DISPATCH_TABLE_NAME: define an array of function pointers, named DISPATCH_TABLE_NAME
			It can be casted to glapi_table, and has additional slots can
			be filled by DRI driver.
- glapitable.h is generated by gl_table.py, defining struct glapi_table
- glapioffsets.h is generated by gl_offsets.py, defining the index of a funtion
  into struct glapi_table.  if used in dri driver, part of the indices are
  remapped by driDispatchRemapTable.
- glprocs.h is generated by gl_procs.py, defining gl_string_table, which is a char[] for
  function names seperated by \0, and static_functions, which gives indices into
  gl_string_table and into glapi_table through  `_gloffset_XXX`.
- glprocs.h and glapi_getproc.c together are used to implement glXGetProcAddress.
- glapi.c defines NoOp dispatch which is used to catch runtime errors.  Its main
  purpose is to provide `_glapi_{set,get}_{dispatch,context}` implemented by
  `_glapi_{tls_,}{Dispatch,Context}` and TSD: see glapi.c
- dispatch.c uses gl_apitemp.h to generate the real entry points (NAME==gl)
  which make use of `_glapi_get_dispatch`
- `_glapi_add_dispatch` is a special function to dynamically add symbols.
  for DRI libGL.so, dri driver is dynamically loaded and the extensions
  supported are different on each dri driver.  Dynamically add symbols.
- `glXGetProcAddressARB` calls `_glapi_get_proc_address`
- `glXMakeCurrent` calls
  - `_glapi_set_dispatch(NULL)` when resetting the context
  - `_glapi_set_dispatch(IndirectAPI)` when indirect rendering
- dispatching
  - `struct _glapi_table` defines a dispatch table for OpenGL
    functions/extensions.
    - Its members are named after OpenGL functions, with prefix `gl` stripped.
    - It is accessed through `SET_Xxxx`, `Get_Xxxx`, and `Call_Xxxx`.
  - `struct dd_function_table` the `Driver` of a context
    - `glViewport` calls `CALL_Viewport` which usually calls `_mesa_Viewport`
      which will finally calls driver's `Viewport`.
    - Not every function calls into driver.
  - With ASM dispatching, `main/dispatch.c` is empty and `x86/glapi_x86.S` is
    used.  Any gl function will go through finding out the address of the
    dispatch table and jump to the position given by dispatch table at certain
    offset.  The code is dynamically patched by `init_glapi_relocs`.
  - `_glapi_add_dispatch` adds a member to dispatch table.  Given function name
    and its parameters, a new offset in the table is assigned and an entry point
    is dynamically allocated.  When a user calls the function using the entry
    point, it goes through the same codepath as static gl functions would do.
    That is, it looks up in the dispatch table to know where to jump to.  If the
    given function name already exists (previously added or static), no new
    offset is assigned.  It is only supported by ASM dispatching.

## Multi-threading

- `glthread.h` defines `THREADS` if `PTHREAD` is defined
- `GET_DISPATCH()`
  - returns `_glapi_Dispatch` if thread support is disabled
  - when `THREADS` is defined, it returns `_glapi_Dispatch` if there is only one
    thread using mesa.  If a second thread uses mesa, `_glapi_Dispatch` is set
    to `NULL` and `GET_DISPATCH` returns what `_glapi_get_dispatch` returns,
    which calls `pthread_getspecific`.
  - when `GLX_USE_TLS` is defined, thread support is done by TLS.
    `GET_DISPATCH` always returns `_glapi_tls_Dispatch`.
- `GET_CURRENT_CONTEXT()` is similar.
- x86 PTHREAD dispatching
  - every gl stub is 32bytes, the last bytes are paddings
  - it test `_glapi_Dispatch` for zeroness.  If non-zero, jmp directly.  If
    zero, it calls `_x86_get_dispatch` and jmp.
  - `generate_entrypoint` can generate a new stub dynamically
- x86 TLS dispatching
  - every gl stub is 16bytes, the last bytes are paddings
  - it calls `_x86_get_dispatch` to get the dispatch pointer.  An `nop`.  And it
    jumps to the real function.
  - The `nop` is a placeholder.  every stub is patched in `init_glapi_relocs`
    so that it does not call `_x86_get_dispatch`.  Instead,
    `_glapi_tls_Dispatch` is calculated only once.  The above is not correct.
  - `_x86_get_dispatch` is really tricky.  It uses `call` to find the position
    of itself, which is combined with `GLOBAL_OFFSET_TABLE`.

## Dispatch Table

- Client APIs will jump to an entry in the dispatch table.  We want to find out
  where the entry points to in this section.
- Main context is initialized by `_mesa_initialize_context`.  In there, `Exec`
  and `Save` are allocated with no-op functions.
- `_mesa_init_exec_table` initializes `Exec`.
  - Most entries are made to point to `_mesa_Xxx`.
  - `_mesa_loopback_init_api_table` is called to point less-generic vtxfmt
    functions to loopbacks.
    - E.g. `Vertex3i` points to `loopback_Vertex3i` which `CALL_Vertex3f`.
  - generic vtxfmt function entries are not dispatched at this point.
- `_mesa_init_dlist_table` initializes `Save`.
  - Most entries are made to point to functions defined in `dlist.c` to compile
    a display list.
  - Some points to `_mesa_Xxx` directly.
  - vtxfmt function entries are handled just like `Exec`.
- `_mesa_install_save_vtxfmt` is then called to initialize vtxfmt in `Save`.
  - generic vtxfmt function entries are made to point to pointers from
    `ctx->ListState.ListVtxfmt`, which is initialized earlier with functions
    from `dlist.c` when `_mesa_save_vtxfmt_init` is called.
- `_mesa_init_exec_vtxfmt` is then called to initialize vtxfmt in `Exec`.
  - generic vtxfmt function entries are made to point to pointers from
    `neutral_vtxfmt`.
  - Neutral function will replace itself with one from the `TnlModule` upon
    called, which can be changed by `_mesa_install_exec_vtxfmt`.
  - `_mesa_restore_exec_vtxfmt` restores all the entries to neutral ones.
  - Calling any vtxfmt function will segfault at this point as they are not
    properly dispatched yet.
- Later, when `_vbo_CreateContext` is called,
  - `_mesa_install_exec_vtxfmt` is called to properly dispatch exec vtxfmt
    functions.  They are dispatched by neutral functions indirectly to
    `_mesa_Xxx`, `_mesa_noop_Xxx`, and `vbo_Xxx`.
  - `_mesa_install_save_vtxfmt` is called again to update vtxfmt functions in
    `Save`.  Some of the functions will be dispatched to functions in
    `vbo_save_api.c`.  It is to make sure that in list mode, `glBegin`/`glEnd`
    are also handled by `vbo`, and they become a single opcode in the save list.
- Some notes about the complexity
  - Some vtxfmt functions are dispatched indirectly to `_mesa_noop_Xxx`.  They
    are rare, special, and not really no-op.
  - Most vtxfmt functions are generated from `vbo_attrib_tmp.h`.
  - If you grep for `_mesa_restore_exec_vtxfmt`, you can see that it is called
    when flushing vertices.  This is to make sure that neutral ones are called
    when any vtxfmt function is called after flushing.  I don't quite buy the
    mechanism though.
  - After `glNewList`, dispath table is switched to `Save`.  It switches back
    after `glEndList`.  `glNewList` must be called with
    `PRIM_OUTSIDE_BEGIN_END`.  After the call, it becomes `PRIM_UNKNOWN`.  After
    first begin, it becomes `PRIM_INSIDE_UNKNOWN_PRIM` and `vbo_save_api.c`
    takes place.  After end, it becomes `PRIM_OUTSIDE_BEGIN_END` and `dlist.c`
    takes place again.

## ABI OS

- When `GLX_USE_TLS` is defined, `.note.ABI-tag` is defined to require kernel
  newer than 2.4.20 in `mesa/x86/glapi_x86.S`.

## gl_API.xml

- It is splitted into categories
  - An OpenGL version is a category
  - An extention is also a category
- Static dispatching
  - A static dispatching has its name as the function name, qualified by
    `KEYWORD1`.
  - A non-static dispatching has `_dispatch_stub_<offset>` as the function name,
    qualified by `KEYWORD1_ALT`.  The qualifier usually hides the entry point.
  - Alias tells how to dispatch a function.  See `ActiveTextureARB` for example.
- `sop` gives standard opcode; `vendorpriv` gives vendor-specific opcode
  - They are used by GLX.
  - See `DeleteTexturesEXT` and `DeleteTextures`.
  - The former is defined in GLX indirect rendering.  Therefore, there is no
    need for it to be in `glapitemp.h` when `GLX_INDIRECT_RENDERING` is defined
    to enable indirect rendering.
- Compare `ColorTable`, `ColorTableSGI`, and `ColorTableEXT`.
  - The latter two are alias to the first function.
  - `ColorTableSGI` has no static dispatching.  It is available through `GetProcAddress`.
    (Might not be true is nobody calls `_glapi_add_dispatch` for it)
- `struct _glapi_table` allocated in `alloc_dispatch_table` has
  `_glapi_get_dispatch_table_size` entries.  There are 300 dynamic dispatches.

## Remap

- Search for "Protosal to re-work GL dispatch"
- `glXGetProcAddress` might be called before a DRI driver is loaded.  Because we
  don't know what a DRI driver may support, it should never return `NULL`.  In
  case there is no static dispatch, a stub is generated.  The stub will be later
  updated by the DRI driver.
  - The stub calls the function at offset `~0` in the dispatch table 
  - `~0` is later replaced by the real offset.
  - See `add_function_name`.
- For each extension, `driInitExtensions` is called.  It `_glapi_add_dispatch`
  new functions defiend by the extension.
  - It must decides the offset in the dispatch table for each new function.
  - For a single function, there can be several names (suffixed by `ARB`, `EXT`,
    etc.).  They _must_ have the same offset.
  - If a function can be statically dispatched, the static offset is used.
  - Otherwise, a dynamic offset is assigned.  A stub is generated, if not yet,
    and the stub is filled with the dynamic offset.
- Remapping
  - OpenGL and several core extensions are statically dispatched.
  - Others are dynamically dispatched.
  - Say, `mesa/main/` wants to call `glXxx`.  It can do so by calling
    `CALL_Xxx`.  If `Xxx` is statically dispatched, `disp->Xxx` is called.  If
    `Xxx` is dynamically dispatched, it should go through remapping.
  - In dynamic case, when `Xxx` is added to dispatch table, a stub and an offset
    are generated.  An entry is also added to the remapping table saying that
    `remap[Xxx] = offset`.  This is why `CALL_Xxx` can call the correct
    function.

## `glproc.h`

- There are some TODOs
  - `static_functions` can be ordered alphabetically, and there is no need for
    another table
  - Replace `GLX_INDIRECT_RENDERING` by `_GLAPI_HIDE_GLX`
    - some functions (those defined in `EXT_texture_object`) has different
      protocols when being incorporated into ABI.
    - glapi should not generate entry points for these functions, otherwise,
      indirect rendering will not respect the proto differences.
    - similarly, `_glapi_get_proc_address` should not know about them.  They are
      not available in `static_functions` either.
    - GLX should define them and getproc should be able to get them.
    - But mesa claims to support `GL_EXT_texture_object`?  What if GLX is too
      lazy to provide them?
    - Another way is to not to static dispatch them.  But glapi getproc should
      be able to return them.
    - GLX could provide its own static dispatches and getproc, and users never
      get glapi's.
    - Then the macro might be called `!_GLAPI_DISPATCH_ALL`
