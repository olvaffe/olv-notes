ARM Mali
========

## History

- 2007: Utgard
  - GLES 2.0
  - non-unified, vector isa
  - Mali-{200,300,400,450}
- 2010: Midgard
  - GLES 3.1
  - unified, vector isa
  - 1 to 4 unified shader cores
  - 2 or 4 ALUs per shader core
  - 4x or 16x FSAA
  - 1 MMU
  - 32KB to 256KB L2
  - 16x16 tiles
  - Mali-{T604,T658}
- 2012: Midgard 2nd gen
  - ASTC
  - Mali-{T622,T624,T628,T678}
- 2013: Midgard 3nd gen
  - GLES 3.2
  - 4x to 16x MSAA
  - 256KB to 2048MB L2
  - 1 to 16 cores
  - AFBC framebuffer compression
  - Mali-{T720,T760}
- 2014: Midgard 4nd gen
  - Mali-{T820,T830,T860,T880}
- 2016: Bifrost
  - Unified shaders with quad vectorization
  - Scalar ISA
  - Clauses execution
  - 1 to 32 cores
  - Full cache coherency
  - Mali-{G31,G51,G71}
- 2017: Bifrost 2nd gen
  - Mali-{G52,G72}
  - e.g., corsola
- 2018: Bifrost 3nd gen
  - 8 execution lanes per engine (up from 4). Doubled pixel and texel
    throughput.
  - Mali-G76
- 2019: Valhall
  - New superscalar engine
  - Simplified scalar ISA
  - New dynamic scheduling
  - Mali-{G57,G77}
  - e.g., cherry
- 2020: Valhall 2nd gen
  - Asynchronous clock domains
  - New FMA units and increase Tiler throughput
  - Arm Frame Buffer Compression (AFBC) 1.3
  - Mali-{G68,G78}
  - e.g., pixel 6
- 2021: Valhall 3rd gen
  - Larger shader cores (2x compared to Valhall 2nd Gen)
  - New GPU frontend, Command Stream Frontend (CSF) replaces the Job Manager (JM)
  - Mali-{G310,G510,G610,G710}
  - e.g., pixel 7, dimensity 9000
- 2022: Valhall 4th gen
  - Ray Tracing support (hardware-based)
  - Variable Rate Shading
  - New Execution Engine, with doubled the FMA block, Matrix Multiply instruction support, and PPA improvements
  - Arm Fixed Rate Compression (AFRC)
  - Mali-{G615,G715}, Immortalis-G715
  - e.g., pixel 8, pixel 9, dimensity 9200
- 2023: 5th gen
  - Deferred vertex shading (DVS) pipeline
  - Mali-{G620,G720}, Immortalis-G720
  - e.g., dimensity 9300
- 2024: 5th gen
  - Mali-{G625,G725}, Immortalis-G925
  - e.g., dimensity 9400
- 2025: G1
  - Mali G1-{Pro,Premium,Ultra} (was G6xx/G7xx/G9xx)
  - e.g., dimensity 9500

## Resources

- <https://developer.arm.com/documentation/102849/latest/>
- <https://developer.arm.com/documentation/101574/latest/>
- Performance Counters
  - <https://developer.arm.com/documentation/102812/latest/>
  - <https://developer.arm.com/documentation/107775/latest/>
    - there is a counter that increments every gpu cycle, which is subjected
      to dvfs and pm
    - `$MaliGPUCyclesAnyQueueActive` increments when any queue has any work in
      a gpu cycle
      - gpu utilization is thus `$MaliGPUCyclesAnyQueueActive / GpuCycles * 100`
    - `$MaliShaderCoreCyclesAnyWorkloadActive` increments when any shader core
      has any work in a shader core cycle
      - shader core may have a lower freq than `GpuCycles` on some devices
      - on such devices, shader core utilization is never 100%
    - `$MaliShaderCoreCyclesExecutionCoreActive` increments when the shader
      core has any warp
      - shader core includes the entire fs pipeline (rasterizer, eu, blender)
        - compute makes use of eu only
      - eu utilization is thus
        `$MaliShaderCoreCyclesExecutionCoreActive / $MaliShaderCoreCyclesAnyWorkloadActive * 100`
  - <https://developer.arm.com/documentation/108081/latest>
  - <https://developer.arm.com/documentation/109780/latest>
  - <https://developer.arm.com/documentation/109793/latest/>
- <https://community.arm.com/arm-community-blogs/tags/GPU>

## Identification

- `GPU_ID` register
  - bit 0..3: status
  - bit 4..11: minor
  - bit 12..15: major
  - bit 16..31: id
    - bit 16..19: product
    - bit 20..23: arch revision
    - bit 24..27: arch minor
    - bit 28..31: arch major
- `pan_arch()`
  - midgard: v4 and v5
    - the 16-bit id is less than `0x1000`
    - a table is used to look up the arch versions
  - bifrost: v6 and v7
    - `id >> 12` is the arch versions
  - valhall: v9 and v10
- kbase uses arch major and product for identification
  - also <https://gitlab.freedesktop.org/panfrost/valhall-docs/-/blob/main/Appendix.md>
  - `GPU_ID_PRODUCT_TMIX` is `GPU_ID_MODEL_MAKE(6, 0)`
    - Mali-G71, bifrost
    - mimir
  - `GPU_ID_PRODUCT_THEX` is `GPU_ID_MODEL_MAKE(6, 1)`
    - Mali-G72, bifrost 2nd
    - heidmall
  - `GPU_ID_PRODUCT_TSIX` is `GPU_ID_MODEL_MAKE(7, 0)`
    - Mali-G51, bifrost
    - sigurd
  - `GPU_ID_PRODUCT_TDVX` is `GPU_ID_MODEL_MAKE(7, 3)`
    - Mali-G31, bifrost
    - dvalin
  - `GPU_ID_PRODUCT_TNOX` is `GPU_ID_MODEL_MAKE(7, 1)`
    - Mali-G76, bifrost 3rd
    - norr
  - `GPU_ID_PRODUCT_TGOX` is `GPU_ID_MODEL_MAKE(7, 2)`
    - Mali-G52, bifrost 2nd
    - gondul
  - `GPU_ID_PRODUCT_TTRX` is `GPU_ID_MODEL_MAKE(9, 0)`
    - Mali-G77, valhall
    - trym
  - `GPU_ID_PRODUCT_TNAX` is `GPU_ID_MODEL_MAKE(9, 1)`
    - Mali-G57, valhall
    - natt-a
  - `GPU_ID_PRODUCT_TBEX` is `GPU_ID_MODEL_MAKE(9, 2)`
    - Mali-G78, valhall 2nd
    - borr
  - `GPU_ID_PRODUCT_LBEX` is `GPU_ID_MODEL_MAKE(9, 4)`
    - Mali-G68, valhall 2nd
    - ottr
  - `GPU_ID_PRODUCT_TBAX` is `GPU_ID_MODEL_MAKE(9, 5)`
    - Mali-G78AE
    - borr-ae
  - `GPU_ID_PRODUCT_TODX` is `GPU_ID_MODEL_MAKE(10, 2)`
    - Mali-G710, valhall 3rd gen
    - odin?
  - `GPU_ID_PRODUCT_TGRX` is `GPU_ID_MODEL_MAKE(10, 3)`
    - Mali-G510, valhall 3rd gen
  - `GPU_ID_PRODUCT_TVAX` is `GPU_ID_MODEL_MAKE(10, 4)`
    - Mali-G310, valhall 3rd gen
  - `GPU_ID_PRODUCT_LODX` is `GPU_ID_MODEL_MAKE(10, 7)`
    - Mali-G610, valhall 3rd gen
  - `GPU_ID_PRODUCT_TTUX` is `GPU_ID_MODEL_MAKE(11, 2)`
    - Mali-G715, valhall 4th gen
      - Immortalis if high core count and raytracing
      - G615 if low core count
    - turse?
  - `GPU_ID_PRODUCT_LTUX` is `GPU_ID_MODEL_MAKE(11, 3)`
    - Mali-G615, valhall 4th gen
  - `GPU_ID_PRODUCT_TTIX` is `GPU_ID_MODEL_MAKE(12, 0)`
    - Mali-G720, 5th gen
      - Immortalis if high core count and raytracing
      - G620 if low core count
    - titan?
  - `GPU_ID_PRODUCT_LTIX` is `GPU_ID_MODEL_MAKE(12, 1)`
    - Mali-G620, 5th gen
  - `GPU_ID_PRODUCT_TKRX` is `GPU_ID_MODEL_MAKE(13, 0)`
    - Mali-G725
      - Immortalis-G925 if high core count and raytracing
      - G625 if low core count
    - krake
  - `GPU_ID_PRODUCT_LKRX` is `GPU_ID_MODEL_MAKE(13, 1)`
    - Mali-G625
- panthor
  - `GPU_PROD_ID_MAKE(14, 0)`
    - Mali-G1-Ultra
    - drage
  - `GPU_PROD_ID_MAKE(14, 1)`
    - Mali-G1-Premium
  - `GPU_PROD_ID_MAKE(14, 3)`
    - Mali-G1-Pro

## Utgard

- GLES 2.0
- non-unified shader cores
- one vertex core
  - the vertex core and the tiler share a small L2
  - shade one or two vertices serially
  - output to fixed-function tiler for primitive assembly, clipping, cullling,
    and tile list generation
- multiple fragment cores
  - they share a larger L2
  - L2 size is usually `num_cores * 32KB`
  - data flow within a core
    - tile list reader
    - rasterizer
    - early zs tester
    - fragment thread creater
    - threads doing load, texture, arithmetic, and then retire
    - late zs tester
    - blender
    - tile memory
    - tile writeback
  - a core can run up to 128 threads to hide cache misses and memory latency
  - ISA is SIMD and operate on vec4 fp16

## Midgard

- GLES 3.2
- unified shader cores
- a L2 cache shared by all shader cores
  - size is `num_cores * (32KB or 64KB)`
- given a render pass
  - the driver submits geometry workload to HW first
  - the geometry queue block dispatches the workload to shader cores
  - the driver then submits fragment workload to HW
  - the fragment queue block dispatches the workload to shader cores
- a shader core consists of
  - fixed-function part
    - tile list reader
    - rasterizer
    - early zs tester
    - vertex or fragment thread creator
  - programmable tripipe
    - thread pool
    - three types of pipelines
      - one load/store pipeline w/ L1
      - one texture pipeline w/ L1
      - one or more arithmetic pipelines
	- 128-bit SIMD (4 fp32 or 8 fp16 or 16 i8)
    - thread retire
  - more fixed-function parts
    - late zs tester
    - blender
    - tile memory
    - tile writeback
- 16x16 tiles
- 4KB on-chip memory

## Bifrost

- "The Bifrost GPU architecture and the ARM Mali-G71 GPU"
  - by Jem Davies
- a L2 cache shared by all shader cores
  - size is `num_cores * (64KB or 128KB)`
  - full coherency
- up to 32 unified shader cores, where each core consists of
  - a compute frontend
    - quad creator
  - a fragment frontend
    - tile list reader
    - rasterizer
    - early zs tester
    - quad creator
  - a quad manager
    - warp manager
  - up to three execution engines, each
    - 32-bit scalar ISA
    - bifrost uses 4-lane quad-parallel vectorization (SIMT...)
      - a quad is 4 scalar threads executed in lockdep
      - one quad at a time executes in each pipeline stage
      - each thread fills a 32-bit lane of the hardware
      - 4 threads all doing a vec fp32 add take 3 cycles
    - midgard uses 4-lane SIMD vectorization
      - one thread at a time executes in each pipeline stage
      - each thread must fill the width of the hardware
      - 4 threads all doing a SIMD vec3 fp32 add take 4 cycles
  - load/store unit
  - attribute unit
  - varying unit
  - texture units (one or two)
  - zs/blend units (one or two)
    - late zs tester
    - blender
    - tile memory
    - tile writeback
- geometry pipeline
  - instead of 'shade -> assembly -> clip/cull`
  - it does 'assembly -> position shade -> clip/cull -> varying shade`
  - specifically,
    - tiler fetches indices for primitive assembly
    - position shading fetches and transforms only positions
    - tiler clips/culls and stores
      - transformed positions
      - polyton list 
    - varying shading fetches attributes and stores varyings
    - fraghment shading reads back
      - transformed positions
      - polyton list 
      - varyings
  - it is beneficial to have two packed buffers, one for positions and one for
    attributes

## Valhall

- G77 high-level features
  - better AR and ML
  - a new superscalar engine
  - a simplified scalar ISA that is more compiler-friendly
  - dynamic scheduling of instructions
  - data structures that are more Vulkan-friendly
  - 16-wide warps, 32 lanes
    - G76 has 8-wide warps, 24 lanes
  - quad texture mapper, 4 texels/cycle
    - G76 is 2 texels/cycle
  - AFBC 1.3
- a shader core consists of
  - a compute frontend
  - a fragment frontend
  - a manager
  - an execution engine
    - front-end
      - create/retire warps
      - track states for warps
    - scheduler
      - issue instructions
    - two processsing units, each
      - 16-wide FMA unit
      - 16-wide CVT unit (convert unit)
      - 4-wide special function unit
  - an attribute unit
  - a varying unit
  - 4x texture unit
  - a load-store cache
    - replaces the load-store unit

## Valhall Arch

- high-level blocks
  - csf
  - core group: tiler, mmu, l2, etc.
  - shader stacks: each shader stack has an array of shader cores
- OF node
  - `power-domains` has one power domain for the entire gpu
  - `clocks` has 3 clocks
    - `core` is for csf and reg access
      - this is also the clock controlled by devfreq/opp
    - `coregroup` is for tiler, mmu, l2, mem access
      - this is optional and should have the same freq as `core`
    - `stacks` is for shader stacks and shader cores
      - this is optional and should have the same freq as, or lower freq than,
        `core`
  - `interrupts` has 3 interrupts
    - `job` is from csf
      - `panthor_job_irq_handler` saves the events
      - `process_fw_events_work` handles the events (e.g., job completions)
    - `mmu` is from mmu in core group
      - `panthor_mmu_irq_handler` handles mmu faults
    - `gpu` is from the rest of blocks
      - `panthor_gpu_irq_handler` handles gpu faults and `GPU_CMD` events
- fine-grained power domains
  - these blocks can be individually powered: tiler, l2, shader cores
  - each block a set of pm-related regs
    - `PWRON` powers a block on, which takes time
    - `PWROFF` powers a block off, which takes time
    - `PWRTRANS` indicates blocks being powered on/off
    - `READY` indicates block powered on and ready to execute
  - there are also
    - `PRESENT` indicates available blocks
    - `PWRACTIVE` indicates busyness
- gpu cmds
  - there is a `GPU_CMD` reg for reset and cache flush
  - `panthor_gpu_flush_caches` flushes caches, and blocks until a gpu irq with
    `GPU_IRQ_CLEAN_CACHES_COMPLETED`
  - `panthor_gpu_soft_reset` soft-resets, and blocks until a gpu irq with
    `GPU_IRQ_RESET_COMPLETED`
- caches
  - all memory accesses go through mmu and reach l2 first
    - including csf, tiler, shader core, etc.
  - each shader core also has
    - lsc, load/store cache
    - other read-only caches for texture unit, attribute unit, etc.
- csf
  - MCU
    - it runs the firmware
    - it schedules and sends the command streams to CEUs
      - it parses and executes some of the cs commands
  - CEUs, command execution units
    - it parses and executes the cs commands
    - idvs jobs are executed by the bin iterator
      - and then dispatched tiler
    - compute jobs are executed by the compute iterator
      - and then dispatched shader core
    - frag jobs are executed by the frag iterator
      - and then dispatched shader core
  - mmio regs
    - mmu control to set up address space
    - gpu control to reset, etc.
- tiler
  - assembles input vertices and indices
  - dispatches position jobs to transform vertex positions
  - clips and culls
  - dispatches varying jobs to transform vertex attributes
  - saves the results as a list of tiles in the tile heap
- shader core
  - compute frontend
    - it creates warps and dispatches them to the execution engine
  - fragment frontend
    - it is similar, but also includes rasterization, earlyz, etc.
  - execution core
    - execution engines
    - lsc
    - attribute unit
    - varying unit
    - texture unit
  - fragment backend
    - blender, tile buffer, and tile writeback
    - depth and stencil
