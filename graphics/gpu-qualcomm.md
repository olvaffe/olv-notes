Qualcomm Adreno
===============

## History

- Snapdragon S series
  - discontinued
  - S1
    - 2007-2008
    - MSM7x27
    - 65nm
    - Adreno 200, GLES 2.0
  - S2
    - 2010
    - MSM7x30, MSM8x55
    - 45nm
    - Adreno 205, GLES 2.0
  - S3
    - 2010
    - MSM8x60
    - 45nm
    - Adreno 220, GLES 2.0
  - S4
    - 2012
    - MSM8x{25,27,30,60}
    - 28nm-45nm
    - Adreno 203, 225, 305, 320
- Snapdragon 2 series
  - ultra budget
  - 200
    - 2013
    - MSM8x{10,12}
    - 28nm
    - Adreno 302
  - 205, 208, 210, 212
    - 2014-2017
    - MSM8x{05,08,09}
    - 28nm
    - Adreno 304
  - 215
    - 2019
    - QM215
    - 28nm
    - Adreno 308
- Snapdragon 4 series
  - entry level
  - 400
    - 2013
    - MSM8x{26,28,30}
    - 28nm
    - Adreno 305
  - 410, 412, 415
    - 2014-2015
    - MSM8x{16,29}
    - 28nm
    - Adreno 306, 405
  - 425, 427, 430, 435
    - 2015-2016
    - MSM8x{17,20,37,40}
    - 28nm
    - Adreno 308, 505
  - 429, 439, 450
    - 2017-2018
    - SDM{429,439,450}
    - 12nm-14nm
    - Adreno 504, 505, 506
  - 460
    - 2020
    - SM4250
    - 11nm
    - Adreno 610
  - 480
    - 2021
    - SM4350
    - 8nm
    - Adreno 619
- Snapdragon 6 series
  - mid-range
  - 600
    - 2013
    - APQ8064
    - 28nm
    - Adreno 320
  - 610, 615, 616
    - 2014-2015
    - MSM89{36,39}
    - 28nm
    - Adreno 405
  - 625, 626
    - 2016
    - MSM8953
    - 14nm
    - Adreno 506
  - 650, 652, 653
    - 2016
    - MSM89{56,76}
    - 28nm
    - Adreno 510
  - 630, 636, 660
    - 2017
    - SDM{630,636,660}
    - 14nm
    - Adreno 508, 509, 512
  - 632, 670
    - 2018
    - SDM{632,670}
    - 10nm-14nm
    - Adreno 506, 615
  - 662, 665, 675, 678
    - 2019-2020
    - SM61{15,25,50}
    - 11nm
    - Adreno 610, 612
  - 680, 690, 695
    - 2020-2021
    - SM{6225,6350,6375}
    - 6nm-8nm
    - Adreno 610, 619
- Snapdragon 7 series
  - upper mid-range
  - 710, 712
    - 2018-2019
    - SDM{710,712}
    - 10nm
    - Adreno 616
  - 720, 730, 732
    - 2019-2020
    - SM71{25,50}
    - 8nm
    - Adreno 618
  - 750, 765, 768
    - 2020
    - SM72{25,50}
    - 7nm
    - Adreno 620
  - 778, 780
    - 2021
    - SM73{25,50}
    - 5nm-6nm
    - Adreno 642
- Snapdragon 8 series
  - high-end
  - 800, 801, 805
    - 2013-2014
    - MSM8x74, APQ8084
    - 28nm
    - Adreno 330, 420
  - 808, 810
    - 2015
    - MSM9x{92,94}
    - 20nm
    - Adreno 418, 430
  - 820, 821
    - 2016
    - MSM8996
    - 14nm
    - Adreno 530
  - 835
    - 2017
    - MSM8998
    - 10nm
    - Adreno 540
  - 845
    - 2018
    - SDM845
    - 10nm
    - Adreno 630
  - 855, 860
    - 2019, 2021
    - SM8150
    - 7nm
    - Adreno 640
  - 865, 870
    - 2020-2021
    - SM8250
    - 7nm
    - Adreno 650
  - 888
    - 2021
    - SM8350
    - 5nm
    - Adreno 660
  - 8 Gen1
    - 2022
    - SM8450
    - 4nm
    - Adreno 730
- Snapdragon 7 Compute Platforms
  - 7c
    - 2020
    - SC7180
    - 8nm
    - Adreno 618
  - 7c Gen2
    - 2021
    - SC7180P
    - 8nm
    - Adreno 618
  - 7c+ Gen3
    - 2021
    - SC7280?
    - 6nm
    - Adreno 7c+ Gen3 (Adreno 635)
- Snapdragon 8 Compute Platforms
  - 835, 850
    - 2018
    - MSM8998, SDM850
    - 10nm
    - Adreno 540, 630
  - 8c, 8cx, 8cx Gen2
    - 2019-2020
    - SC8180
    - 7nm
    - Adreno 675, 680, 690
  - 8cx Gen3
    - 2022
    - SC8???
    - 5nm
    - Adreno 8cx Gen3

## Architecture

- `Qualcomm® Snapdragon™ Mobile Platform OpenCL General Programming and Optimization`
- Adreno
  - a big L2 sitting in from of system memory
    - all memory accesses from SP are via L2
  - a Texture Processor / L1 for Sampling and Image Read
  - multiple Shader Processors
- a Shader Processor (SP) is
  - core block of Adreno GPUs with many moudles including ALU, load/store
    unit, control flow unit, register files, etc.
  - each SP corresponds to a OpenCL compute unit
  - load/store through L2 for buffer objects and (r/w) image objects
  - load/sample through  texture processor / L1 for read-ony image objects
- a Texture Processor (TP) is
  - texture fetching and filtering
  - coupled with L1 which fetches data from L2
- A unified L2 cache (UCHE)
  - respond to SP's load/store and L1's load requests
- Waves and fibers
  - the smallest unit of execution is a fiber (thread...)
  - a collection of fibers execute in lock-step is a wave
  - wave size can be 8, 16, 32, 64, 128, etc.
  - a SP can have multiple active waves, for latency hiding
    - maximum number of active waves depend on register file size and register
      footprint of the waves
  - an OpenCL kernel launches multiple workgroups
    - each workgroup is assigned to an SP
    - each SP processes one (or multiple on highend) workgroup at a time
    - the remaining SPs are queued in GPU for execution
  - an OpenCL workgroup is processed by multiple waves
    - the larger the better, but not always
    - larger workgroups means more waves and better latency hiding
- OpenCL Memory Model
  - global memory is system memory
  - local memory is on-chip GMEM in SP
  - private memory is registers, on-chip GMEM, or system memory decided by
    compiler
  - constant memory is on-chip if can fit; system memory otherwise
  - not coherent between CPU/GPU on A5xx
- Graphics Fixed-Function Pipeline
  - Command Processor (CP)
    - uncached
  - Color Cache Unit (CCU)
    - draws and blits hit CCU

## PM4 Command Packets

- From Radeon South Island Programming Guide
  - Packet DW0[31:30] spcifies the type
  - Type 0 updates registers in the first 64K DW
    - use type 3 instead
    - `type0(u16 startReg, u14 count, u32 value[count])`
  - Type 2 is no-op, to fill up the trailing space
  - Type 3 executes the specified opcode
    - `tyep3(u8 opcode, bool predicate, u32 payload[])`
    - Initialization Packets
      - `MI_INITIALIZE`
    - Command Buffer Packets
      - `INDIRECT_BUFFER`
    - Draw/Dispatch Packets
      - `DRAW_INDEX`
      - `DRAW_INDEX_AUTO`
      - `DRAW_INDIRECT`
    - State Management Packets
    - Command Predication Packets
    - Synchronization Packets
      - `EVENT_WRITE`: initiate an event and optionally write a value to the
        specified address when the event completes
    - Atomic
    - Misc Packets
- From freedreno
  - type 7 works similar to type 3
  - type 4 works similar to type 0

## CP, Command Processor

- CP has ME (microengine) and PFP (prefetch parser)
  - PFP adds commands to a FIFO named MEQ
  - ME processes commands from MEQ
  - since a6xx, they are replaced by SQE
  - see also
    - `afuc/README.rst`
    - `registers/adreno/adreno_pm4.xml`
- command processing
  - `CP_INDIRECT_BUFFER` calls an indirect buffer (IB)
    - actually, CP executes commands from a ring buffer (RB) controlled by
      kernel
    - userspace submissions are IB1 added to RB
    - userspace indrect buffers are IB2 added to IB1
  - `CP_COND_EXEC` conditionally execs the following N dwoard based on values
    at addrs
    - `addr1 != 0`
    - `addr1 < ref`
  - `CP_COND_REG_EXEC` conditionally execs the following N dwords based on reg
    - can be used with `CP_REG_TEST`
    - can check reg1==reg2
    - can test the operation mode (binning, sysmem, or gmem) set by
      `CP_SET_MARKER`
  - `CP_SET_MARKER` tells CP the current operation mode
  - `CP_REG_TEST` tests a reg, as cond exec predicate
- synchronization
  - `CP_WAIT_FOR_ME` tells PFP to wait for ME
  - `CP_WAIT_FOR_IDLE` tells ME to wait for the pipeline to be idle?
  - `CP_WAIT_MEM_WRITES` waits mem writes from ME?
- memory access
  - CP memory access is uncached
  - `CP_MEM_WRITE` writes a dword or qword to addr
  - `CP_MEM_TO_MEM` copies a qword with alu
  - `CP_MEMCPY` copies N dwords
  - `CP_COND_WRITE5` writes addr if val at another addr meets the condition
  - `CP_REG_TO_MEM` copies a reg to addr
  - `CP_WAIT_REG_MEM` waits for addr to meet a condition
- register access
  - `CP_REG_WRITE` writes a reg
    - removed on latest gens
  - `CP_CONTEXT_REG_BUNCH` writes regs
  - `CP_REG_RMW` increments/decrements/rmw a reg
  - `CP_MEM_TO_REG` copies addr to reg
- 2d blit
  - `CP_BLIT` works great for clears, copies, and blits
    - when its restrictions are satisfied
    - non-msaa, supported formats, etc.
- compute dispatch
  - `CP_EXEC_CS` dispaches
  - `CP_EXEC_CS_INDIRECT` dispaches with params on a buffer
- draw / dispatch
  - `CP_SET_MODE` executes `CP_SET_DRAW_STATE` immediately when 0x1
  - `CP_SET_BIN_DATA5_OFFSET` sets binning configuration
  - `CP_SET_VISIBILITY_OVERRIDE` ignores visibility stream when 0x1
  - `CP_SKIP_IB2_ENABLE_GLOBAL` ignores `CP_INDIRECT_BUFFER`
    - can be useful in binning pass
  - `CP_LOAD_STATE6_GEOM` preloads consts, ubos for VS/HS/DS/GS
  - `CP_LOAD_STATE6_FRAG` preloads consts, ubos for FS/CS
  - `CP_SET_DRAW_STATE` is `CP_INDIRECT_BUFFER` on steroids
    - it allows drivers to construct stateobjs (IBs)
    - it can conditionally exec stateobjs depending on the operation mode and
      whether the stateobjs have changed
  - `CP_SET_SUBDRAW_SIZE` sets the tess factor/param buffer size for HS
  - `CP_DRAW_INDX_OFFSET` draws
  - `CP_DRAW_INDIRECT_MULTI` draws indirectly
  - `CP_DRAW_AUTO` draws using transform feedback data
  - `CP_DRAW_PRED_ENABLE_GLOBAL` enables/disables conditional rendering
  - `CP_DRAW_PRED_ENABLE_LOCAL` enables/disables conditional rendering
    internally for internal draws
  - `CP_DRAW_PRED_SET` sets the predicate bit for conditional rendering
- `CP_EVENT_WRITE` generates an "event" and optionally writes to an addr when
  the event completes
  - `BLIT`
  - `CACHE_FLUSH_TS` flushes UCHE
  - `CACHE_INVALIDATE` invalidates UCHE
  - `FLUSH_SO_0(i)` writes SO results to `REG_A6XX_VPC_SO_FLUSH_BASE(i)`
  - `LRZ_FLUSH` is generated at tile render begin/end and sysmem begin/end
  - `PC_CCU_FLUSH_COLOR_TS` flushes CCU color cache
  - `PC_CCU_FLUSH_DEPTH_TS` flushes CCU depth cache
  - `PC_CCU_INVALIDATE_COLOR` invalidates CCU color cache
  - `PC_CCU_INVALIDATE_DEPTH` invalidates CCU depth cache
  - `PC_CCU_RESOLVE_TS` is generated at tile render end
  - `RB_DONE_TS` waits for end-of-pipe to complete
  - `RST_PIX_CNT` resets pixel count?
  - `RST_VTX_CNT` resets vertex count?
  - `START_PRIMITIVE_CTRS` starts primitive counters
  - `STOP_PRIMITIVE_CTRS` stops primitive counters
  - `STAT_EVENT` for queries
  - `TILE_FLUSH` for queries
  - `UNK_2C`
  - `UNK_2D`
  - `WRITE_PRIMITIVE_COUNTS` writes primitive counts to addr specified in
    `REG_A6XX_VPC_SO_STREAM_COUNTS` for xfb
  - `ZPASS_DONE` writes zpass fragment count to addr specified in
    `A6XX_RB_SAMPLE_COUNT_ADDR`
