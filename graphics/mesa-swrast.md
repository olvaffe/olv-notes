Mesa and Its swrast Context
===========================

## swrast

* swrast expects hw driver to provide two functions
  * `SpanRenderStart` is called before sw rendering to give hw driver a chance
    to lock the hardware and map the buffers.
  * `SpanRenderFinish` is called after sw rendering to unmap buffers and unlock.
* By mapping buffers, it might mean to initialize the operation pointers, like
  `PutRow`, of the renderbuffers.
* When fallback to software, hw driver calls `_swsetup_Wakeup` so that
  `tnl->Driver.Render` uses `swrast_setup`.
* in the last stage of pipeline is rendering.  tnl calls its render functions
  to do hw or swrast rendering.
* swrast decides how tnl converts vertices to `SWvertex`
  * It calls `_tnl_init_vertices` in `_swsetup_CreateContext`.
  * It calls `_tnl_install_attrs` in `_swsetup_RenderStart`.
  * It basically describes `struct SWvertex` to tnl.
  * tnl tries to find the fastest emit function from the description.
    1. it checks for fast pathes
    2. it generates fast pathes
    3. it tries hardwired fast pathes
    4. it uses `_tnl_generic_emit`
* have a closer look at rendering
  * `Driver.Render.Start` is called.
  * `Driver.Render.BuildVertices` is called.
    * It is `_tnl_build_vertices`.
    * Vertices are emitted  to `tnl->clipspace.vertex_buf` as `SWvertex`.
  * For each primitive, it is rendered by a render function of its type.
    * the render functions are generated by `t_vb_rendertmp.h`.
    * they are implemented by `Driver.Render.Xxxx`.
    * e.g. the render function for `GL_TRIANGLES` is implemented by calling
      `Driver.Render.PrimitiveNotify` and `Driver.Render.Triangle` multiple
      times.
    * e.g. `Driver.Render.Points` is `swsetup_points`, which calls
      `_swrast_Point`, which calls `SWRAST_CONTEXT(ctx)->Point`, which is one of
      the functions in `s_points.c`, which outputs `SWspan`s.
    * Spans are finally written to renderbuffer by `_swrast_write_rgba_span`.
      This is where fragment program or texture mapping happens.
    * We missed one thing.  Where does `_swrast_Point` or the likes get their
      `SWVertex`?  When `_swsetup_Wakeup` is called, `swsetup->verts` is made to
      piont to `tnl->clipspace.vertex_buf`.
  * `Driver.Render.Finish` is caled.


## Textures

* `_swrast_write_rgba_span` calls `shade_texture_span` to apply shader or
  texturing.  In the latter case, `_swrast_texture_span` is called.
* One of the function from `_swrast_choose_texture_sample_func` is used to
  resample the texture.  Any of the function calls
  `gl_texture_image->FetchTexelf` to retrieve original samples.
  * The fetch function points to `TexFormat`'s fetch function.
  * It access `gl_texutre_image->Data` directly.

## swrast

* User pixel inputs are always converted and/or expanded to RGBA, 4 floats
* For TexImage*, they are converted to internalFormat.
* For DrawPixels, they are converted to fixed-point, just like vertices' color.
* Vertices' color is converted to fixed-point in final color processing, before
  passing to the rasterization.
* the render stage of tnl calls
  * Render.Start
  * Render.BuildVertices
  * one of Render.PrimTabVerts depending on primitive type
  * Render.Finish
* building vertices means output the vertices in renderer's format.
  * e.g., the format of swrast can be seen in `setup_vertex_format`
  * the vertices's color needs to be converted to fixed-point for normal
    rendering.  The vertices built has format `EMIT_4CHAN_4F_RGBA` unless
    there is fragment shader.
  * When `_swrast_write_rgba_span` is called, `span->array->rgba` might not be
    valid.  But when it isn't, a shader is used.
* each primitive is then rendered using PrimTabVerts
  * it is constructed from `t_vb_rendertmp.h`.
  * it calls `Render.Points`, `Render.Line`, `Render.Triangle`, or `Render.Quad`.
  * for swrast, the real impl. is in `_swsetup_choose_trifuncs`.  But it is
    generated from `ss_tritmp.h` and in turn calls `_swrast_Xxx`, where XXX is
    the primitive.  Those functions call what is chosen through
    `_swrast_choose_xxx`.
