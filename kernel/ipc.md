IPC
===

## Pipes

- pipe(7)
- pipe(3) returns two fds; first for reading and second for writing
- this enables one-way communication
- `fs/pipe.c`
  - pipe(2) creates a `S_IFIFO` inode in an internal pipefs fs
  - the inode's `i_fop` is set to `pipefifo_fops`
  - the inode is opened twice,  `O_RDONLY` and `O_WRONLY` respectively

## FIFOs

- fifo(7)
- mkfifo creates a special (`S_IFIFO`) file that can be opened to create
  reading end and writing end
- there can be multiple readers and multiple writers
  - semantics unclear
- work exactly like pipe internally

## System V IPC

- sysvipc(7)
- message queues
  - `msgget(key, flags)` returns the msg queue id
    - key can be generated by `ftok` such that two processes can easily share
      the msg queue
    - in a sense, key is like the filename and msqid is like an fd
  - msgctl manipulates a msg queue
    - file-like access control
    - removal
  - `msgsnd(msqid, ...)` sends a user-defined message using the msg queue id
  - `msgrcv(msqid, ...)` receives the message
  - `ipc/msg.c`
    - user-defined key is used to look up or create a new `msg_queue`
    - `msg_queue` has an id that is returned to userspace
- semaphore sets
  - `semget` returns the semaphore set id
    - the number of semaphores in the set is user-specified
  - `semctl`
  - `semop` defines three ops: wait, signal, get
  - `ipc/sem.c`
    - every semaphore in a set is essential an int
- shared memory
  - `shmget` returns the shm id
    - the size is user-specified
  - `shmctl` to access control and remove
  - `shmat` maps
  - `shmdt` unmaps
  - `ipc/shm.c`
    - a shm is a shmem internally
- each sysvipc object is global with access control
- checking out `ipcs` or `/proc/sysvipc`, only shm is still in use on my
  system

## POSIX IPC

- `mq_overview(7)`
  - `mq_open` to open a mq
  - `mq_send` and `mq_receive` to send and receive
  - `ipc/mqueue.c`
    - internally mount `mqueue` fs
    - open/send/receive/close works on files in the mqueue fs
    - userspace can mount mqueue too
- `sem_overview(7)`
  - `sem_open` opens `/dev/shm/sem.<name>`
  - `sem_post` and `sem_wait` to increment and decrement
  - `/dev/shm` must be mounted
  - no kernel code; a sem is a futex in a shm
- `shm_overview(7)`
  - `shm_open` opens `/dev/shm/<name>`
  - ftruncate to set the size
  - mmap/munmap works
  - `/dev/shm` must be mounted
  - no kernel code
- checking out `/dev/mqueue` and `/dev/shm`, there is no user on my system

## Signals

- signal(7)
- kill(2) sends a signal to a pid
- `kernel/signal.c`
  - adds a signal record (`sigqueue`) to the target's pending list
    (`sigpending`)
  - `signal_wake_up` to inform the target

## Futexes

- futex(7)
- a futex is an atomic int in userspace
- when the userspace `FUTEX_WAIT` for the atomic int to change away from a
  specified value
  - kernel sets up a `futex_q` and adds it `futex_queues`
- when the userspace changes the atomic int and `FUTEX_WAKE`
  - kernel find the `futex_q` and wakes up the waiter
- kernel uses the address of the atomic int as the key of `futex_queues`
  - when the atomic int is private, the address can be used directly
  - when the atomic int is shared, shmem inode and offset are used instead
- a futex is thus a userspace atomic int with an associated kernel wait queue

## Sockets

- socket(7)
- socket(2) returns an fd for an endpoint for communication
  - domain (or address family or protocol family) specifies the protocol
    family
    - `address_families(7)`
    - `AF_UNIX`
    - `AF_INET`
    - `AF_NETLINK`
    - `AF_BLUETOOTH`
  - type specifies the endpoint type
    - `SOCK_STREAM`
    - `SOCK_DGRAM`
    - `SOCK_RAW`
  - protocol specifies the protocol in the protocol family
    - usually 0
    - for `AF_NETLINK`
      - `NETLINK_ROUTE`
      - `NETLINK_SELINUX`
      - `NETLINK_ISCSI`
      - `NETLINK_NETFILTER`
      - `NETLINK_KOBJECT_UEVENT`
- bind(2) sets the address of the endpoint
  - for unix(7), the address is a file name
    - this creates a socket file (`S_IFSOCK`) in the fs
    - linux supports abstract name where no socket file is created
    - socketpair(2) creates two endpoints without any name
- connect(2) connects the endpoint to the address

## Synchronizations

- synchronize access to a shared resource
- semaphore
  - up adds a token (of resource readiness)
  - down waits and removes a token (of resource readiness)
  - naive implementation
    - a semaphore is a futex where the int is the number of tokens (usually
      either 0 or 1)
    - up increments the futex, and `FUTEX_WAKE` if was 0
    - down atomically does `FUTEX_WAIT(0)` and decrements the futex
      - in a loop where only one waiter can decrement and exit
- mutex
  - lock to acquire ownership (of a resource)
  - unlock to relese ownership (of a resource)
  - naive implementation
    - a mutex is a futex where 0 means unlocked and 1 means locked
    - lock sets the futex to 1 or `FUTEX_WAIT(1)`
      - in a loop where only locker can set and exit
    - unlock sets the futex to 0 and `FUTEX_WAKE`
    - a naive mutex can also be considered a naive binary semaphore
      - initial value is 1
      - lock is down
      - unlock is up
- condition variable
  - wait adds the caller to the wait queue
  - signal wakes up and removes the first caller in the wait queue
  - naive implementation
    - a cv is a list (and a mutex to protect the list)
    - wait adds a futex of value 0 to the list, `FUTEX_WAIT(0)`, and remove
      the futex after signaled
    - signal set the first futex to 1 and `FUTEX_WAKE`
- scenarios
  - I have two threads who need to call `produce` and `consume` in a specific
    order (one producer and one consumer)
    - the caller can use a semaphore to order the threads
    - need two semaphores for the produce/consume cycle to keep going
  - I have two threads who want to call `produce` concurrently (two producers)
    - `produce` can use a mutex to avoid race
  - I have two producers and one consumer
    - `produce` and `consume` can use a mutex and a condition variable

## Miscs

- eventfd
- signalfd
- timerfd
- memfd
- userfaultfd
- pidfd
