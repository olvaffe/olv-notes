Das U-Boot
==========

## Overview

- <https://source.denx.de/u-boot/u-boot.git>
- <https://docs.u-boot.org/en/latest/develop/release_cycle.html>
  - quarterly release
  - a release is tagged on the first Monday of each quarter
  - then the merge window is opened for 3 weeks

## Build

- <https://docs.u-boot.org/en/latest/build/gcc.html>
  - `make nanopi-r5c-rk3568_defconfig`
  - `make menuconfig`
  - `make CROSS_COMPILE=aarch64-linux-gnu-`

## Makefile

- dtbs
  - `make -C dts/upstream/src/arm64 dtbs` builds the dtb from upstream dts
    - `CONFIG_DEFAULT_DEVICE_TREE` selects the dts
    - `cmd_dtc` force-includes `dtsi_include_list` and
      `CONFIG_DEVICE_TREE_INCLUDES`
      - if the input is `foo.dts`, `$(basename $(notdir $<))-u-boot.dtsi`
        expands to `foo-u-boot.dtsi`
  - `make -C dts dtbs` builds `dts/dt.dtb`, which is copied from the upstream
    dtb
  - `u-boot.dtb` is copied from `dts/dt.dtb`
- spl
  - `make -f scripts/Makefile.spl all`
    - `INPUTS-y` has `spl/u-boot-spl.bin`
  - `spl/u-boot-spl` is spl in elf format
    - `cmd_u-boot-spl` links `.o` using `u-boot-spl.lds`
      - `u-boot-spl.lds` is from `arch/arm/cpu/armv8/u-boot-spl.lds` unless
        the board has a more specific one
  - `spl/u-boot-spl-nodtb.bin` is spl in binary format
    - it is objcopied from `spl/u-boot-spl`
  - `spl/dts/dt-spl.dtb` is trimmed down from `dts/dt.dtb`
    - `make -C dts spl_dtbs` runs `cmd_fdtgrep` on `dts/dt.dtb`
  - `spl/u-boot-spl.dtb` is copied from `spl/dts/dt-spl.dtb`
  - `spl/u-boot-spl-dtb.bin` is `spl/u-boot-spl-nodtb.bin` and
    `spl/u-boot-spl.dtb` cat'ed together
  - `spl/u-boot-spl.bin` is copied from `spl/u-boot-spl-dtb.bin`
- u-boot proper
  - `u-boot` is u-boot proper in elf format
    - `cmd_u-boot__` links `.o` using `u-boot.lds`
    - `u-boot.lds` is from `arch/arm/cpu/armv8/u-boot.lds` unless the board
      has a more specific one
  - `u-boot-nodtb.bin` is u-boot proper in binary format
    - it is objcopied from `u-boot`
  - `u-boot-dtb.bin` is `u-boot-nodtb.bin` and `dts/dt.dtb` cat'ed together
    - `CONFIG_MULTI_DTB_FIT=n`
    - `CONFIG_OF_SEPARATE=y`
    - `CONFIG_OF_OMIT_DTB=n`
  - `u-boot.bin` is copied from `u-boot-dtb.bin`
  - `u-boot.img` and `u-boot-dtb.img` are u-boot proper plus dtb in fit format
    - they use `MKIMAGEFLAGS_u-boot.img` and `MKIMAGEFLAGS_u-boot-dtb.img` as
      the mkimage flags, and are the same
    - the results are fit images with `u-boot-nodtb.bin` and `dts/dt.dtb`
      appended
- binman
  - dtb includes `arch/arm/dts/rk3588s-orangepi-5-u-boot.dtsi`
    - `/chosen` has `u-boot,spl-boot-order = "same-as-spl", &sdmmc;`
      - boot from where spl resides followed by `sdmmc`
    - `/binman` has two child nodes for `u-boot-rockchip.bin` and
      `u-boot-rockchip-spi.bin`
  - `u-boot-rockchip.bin` is for sdmmc
    - `idbloader.img` consists of
      - `rockchip-tpl` is specified by `ROCKCHIP_TPL`
      - `u-boot-spl` is from `spl/u-boot-spl.bin`
      - `idbloader.img` is generated by `mkimage -n rk3588 -T rksd`, which is
        in a format that the bootrom understands
    - `u-boot.itb` consists of
      - `u-boot` is from `u-boot-nodtb.bin`
      - `@atf-SEQ` is specified by `BL31`
      - `@tee-SEQ` is specified by `TEE`, optional
      - `@fdt-SEQ` is from `u-boot.dtb`
      - the binaries are appended to the itb file
  - `u-boot-rockchip-spi.bin` is for spi flash
    - `idbloader-spi.img` is the same as `idbloader.img`
    - `u-boot.itb` is already generated
    - `u-boot-rockchip-spi.bin` differs from `u-boot-rockchip.bin` in padding
- `_all` is the first target, thus the default target
  - `_all: all` makes `_all` depend on `all`
  - `all: .binman_stamp` and `.binman_stamp: $(INPUTS-y) FORCE`
    - so it depends on `INPUTS-y` and runs `cmd_binman`
  - `INPUTS-y` has
    - `spl/u-boot-spl.bin`
    - `u-boot.dtb`
    - `u-boot.bin`
    - `u-boot.sym`
    - `u-boot.img`
    - `u-boot-dtb.img`

## RK3588

- <https://docs.u-boot.org/en/latest/board/rockchip/rockchip.html>
  - build or get tf-a firmware
    - <https://github.com/ARM-software/arm-trusted-firmware.git>
      - `CROSS_COMPILE=aarch64-linux-gnu- make PLAT=rk3588 bl31`
      - `build/rk3588/release/bl31/bl31.elf` is the image
    - <https://github.com/rockchip-linux/rkbin>
  - get tpl firmware
    - also at <https://github.com/rockchip-linux/rkbin>
  - build uboot
    - `make orangepi-5-rk3588s_defconfig`
    - `ROCKCHIP_TPL=rkbin/bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin
       BL31=arm-trusted-firmware/build/rk3588/release/bl31/bl31.elf
       CROSS_COMPILE=aarch64-linux-gnu- make`
    - `u-boot-rockchip.bin` and `u-boot-rockchip-spi.bin` are the images
      - `arch/arm/dts/rockchip-u-boot.dtsi`
      - `mkimage` packs `rockchip-tpl` (the ddr blob from rkbin) and
        `u-boot-spl` (`spl/u-boot-spl.bin`) into `idbloader.img`
         - this is to be flashed to sector 0x40, mandated by the bootrom
      - `u-boot.itb` is u-boot proper
        - this is to be flashed to sector 0x4000, because
          `CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR` defaults to `0x4000` for
          `CONFIG_ARCH_ROCKCHIP`
  - flash to sdcard
    - `dd if=u-boot-rockchip.bin of=/dev/sda seek=64`
  - flash to spi flash
    - `dd if=u-boot-rockchip.bin of=/dev/mtdblock0`
- boot sequence
  - bootrom jumps to spi flash sector 0x40
  - `ROCKCHIP_TPL=rkbin/bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin`
    - this initializes ddr
  - `spl/u-boot-spl.bin`
    - `_start` of `arch/arm/cpu/armv8/start.S` is the entrypoint
      - it branches to `_main`
    - `_main` of `arch/arm/lib/crt0_64.S`
      - it calls `board_init_f`
      - it branches to `board_init_r`
    - `board_init_f` of `arch/arm/mach-rockchip/spl.c`
      - `preloader_console_init` inits serial and prints `U-Boot SPL` banner
    - `board_init_r` of `common/spl/spl.c`
      - rockchip `board_boot_order` inits the boot order based on `/chosen`
        - `BOOT_DEVICE_SPI` followed by `BOOT_DEVICE_MMC1`
      - `boot_from_devices` loads uboot proper
        - `SPL_LOAD_IMAGE_METHOD` defines the load methods
          - `BOOT_DEVICE_SPI` uses `spl_spi_load_image`
          - `BOOT_DEVICE_MMC1` uses `spl_mmc_load_image`
        - `_spl_load` calls `spl_load_simple_fit`
          - this parses uboot proper in fit format
          - it picks the atf firmware as the entrypoint, with fall back to
            uboot
      - `spl_invoke_atf` jumps to atf entrypoint
  - atf (bl31) in `u-boot.itb`
    - this inits and jumps to bl33
  - `u-boot-nodtb.bin` (bl33) in `u-boot.itb`
    - `_start` of `arch/arm/cpu/armv8/start.S` is the entrypoint
      - it branches to `_main`
    - `_main` of `arch/arm/lib/crt0_64.S`
      - it calls `board_init_f`
      - it branches to `board_init_r`
    - `board_init_f` of `common/board_f.c`
      - it calls all init functions on `init_sequence_f`
      - `serial_init` inits serial
      - `display_options` prints the `U-Boot` banner, `U_BOOT_VERSION_STRING`
      - `show_board_info` prints `Model: ...`
      - `announce_dram_init` prints `DRAM:`
    - `board_init_r` of `common/board_r.c`
      - it calls all init functions on `init_sequence_r`
      - `dm_announce` prints `Core: ...`
      - `initr_mmc` prints `MMC: ...`
      - `initr_env` prints `Loading Environment from ...`
      - `console_init_r` prints `In:`, `Out:`, and `Err:`
      - `show_board_info` prints `Model: ...` again
      - `initr_net` prints `Net: ...`
      - `run_main_loop` runs `main_loop` forever

## Modern Config

- `make foo_defconfig` uses `configs/foo_defconfig`
  - it typically sets
    - `CONFIG_$ARCH=y`, such as `ARM`
    - `CONFIG_ARCH_$VENDOR=y`, such as `ROCKCHIP`
    - `CONFIG_$VENDOR_$SOC=y`, such as `ROCKCHIP_RK3588`
    - `CONFIG_TARGET_$BOARD=y`, such as `EVB_RK3588`
    - `CONFIG_DEFAULT_DEVICE_TREE`
    - `CONFIG_DEFAULT_FDT_FILE`
    - `CONFIG_SYS_LOAD_ADDR`
  - they affect these configs
    - `arch/$ARCH/Kconfig`
      - `CONFIG_SYS_ARCH`
      - `CONFIG_SYS_CPU`
    - `arch/$ARCH/mach-$VENDOR/Kconfig`
    - `arch/$ARCH/mach-$VENDOR/$SOC/Kconfig`
      - `CONFIG_SYS_SOC`
    - `board/$VENDOR/$BOARD/Kconfig`
      - `CONFIG_SYS_VENDOR`
      - `CONFIG_SYS_BOARD`
      - `CONFIG_SYS_CONFIG_NAME`
- `CONFIG_BOOTSTD_DEFAULTS` or `CONFIG_BOOTSTD_FULL` should be enabled
  - some modern defconfigs enable them
  - `CONFIG_BOOTSTD_FULL` implies `CONFIG_BOOTSTD_DEFAULTS`
  - `CONFIG_BOOTSTD_DEFAULTS` implies `CONFIG_BOOT_DEFAULTS` and
    `CONFIG_BOOTMETH_DISTRO`
  - `CONFIG_BOOT_DEFAULTS` is a meta config to enable
    - `CONFIG_SUPPORT_RAW_INITRD` to load raw initrd
    - `CONFIG_ENV_VARS_UBOOT_CONFIG` to include `CONFIG_SYS_*` in default env
    - `CONFIG_EFI_PARTITION` for gpt support
    - `CONFIG_CMD_{EXT2,EXT4,FAT,PART}` for partition and fs support
    - `CONFIG_BOOTCOMMAND` for autoboot with `bootflow scan -lb`
    - `CONFIG_CMD_BOOTI` for `booti` to boot kernel `Image`
    - more
  - `CONFIG_BOOTMETH_DISTRO` is a meta config to enable
    - `CONFIG_BOOTMETH_SCRIPT` for `boot.scr.uimg` (or `boot.scr`) support
    - `CONFIG_BOOTMETH_EXTLINUX` for `extlinux/extlinux.conf` support
    - `CONFIG_BOOTMETH_EXTLINUX_PXE` for pxe
    - `CONFIG_BOOTMETH_EFILOADER` for `/EFI/BOOT/bootaa64.efi` support

## Default Environment

- `include/env_default.h`
  - `bootcmd` is `CONFIG_BOOTCOMMAND`, for autoboot
  - `bootdelay` is `CONFIG_BOOTDELAY`, for autoboot
  - `baudrate` is `CONFIG_BAUDRATE`
  - `loadaddr` is `CONFIG_SYS_LOAD_ADDR`
  - `arch` is `CONFIG_SYS_ARCH`
  - `cpu` is `CONFIG_SYS_CPU`
  - `soc` is `CONFIG_SYS_SOC`
  - `vendor` is `CONFIG_SYS_VENDOR`
  - `board` and `board_name` are `CONFIG_SYS_BOARD`
  - `CFG_EXTRA_ENV_SETTINGS` is extra env defined by board
- `scripts/Makefile.autoconf` generates `include/config.h` to include
  `include/configs/$CONFIG_SYS_CONFIG_NAME.h`
  - they typically define variables for memory layout
    - `kernel_addr_r` for kernel
    - `kernel_comp_addr_r` and `kernel_comp_size` for decompression
    - `fdt_addr_r` for fdt
    - `fdtoverlay_addr_r` for fdtoverlay
    - `ramdisk_addr_r` for initrd
    - `scriptaddr` for boot script
    - `script_offset_f` and `script_size_f` for boot script in spi flash
    - `pxefile_addr_r` for pxe
  - they may also define
  - `boot_targets` for bootdev order
  - `fdtfile` is `CONFIG_DEFAULT_FDT_FILE`, for when `extlinux.conf` specifies
    `fdtdir`
  - `partitions` describes default gpt partition table, for
    `gpt write mmc 0 $partitions`

## CLI

- `bdinfo` prints board info
- boot variants
  - `boot` and `bootd` run `bootcmd` env
  - `bootefi` boots an efi payload
  - `bootelf` boots an elf image
  - `booti` boots a kernel image
  - `bootm` boots an app image
  - `bootp` boots from pxe
  - `bootflow scan -bl` boots boot flows
    - this only considers 
    - `-l` lists boot flows as they are discovered
    - `-b` boots boot flows as they are discovered
- `coninfo` prints console info
- `env` handles env
- `gpt` handles gpt
- load variants
  - `ext2load` loads a file from ext2
  - `ext4load` loads a file from ext4
  - `fatload` loads a file from fat
  - `load` loads a file from any fs?
- `ls` lists a fs
- `mmc` handles mmc
  - `mmc part` lists partitions
- `net list` lists net devices
- `part` handles partitions
  - `part list mmc 0` lists partitions
    - looking at `get_bootable`, only ESP or a partition with
      `Legacy BIOS bootable` bit set is considered bootable
- `pci` lists pci devices
- `run` runs cmds in an env var
- `usb` handles usb
- `version` shows version

## Code Flow: armv8

- `_start:` in `arch/arm/cpu/armv8/start.S`
  - soc-specific `boot0.h` branches to `reset`
  - `reset` branches to `_main`
- `ENTRY(_main)` in `arch/arm/lib/crt0_64.S`
  - calls `board_init_f` in `common/board_f.c`
    - it calls the init functions on `init_sequence_f` array
  - branches to `board_init_r` in `common/board_r.c`
    - it calls the init functions on `init_sequence_r` array
    - some `init_sequence_r` init functions
      - `initr_net` calls `eth_initialize` to initialize NICs
        - console: `Net:   eth0: <name>`
      - `run_main_loop` is the last function and calls `main_loop`
- `main_loop` in `common/main.c`
  - `run_preboot_environment_command` runs `CONFIG_PREBOOT` commands
    - it runs `usb start` by default
      - console: `starting USB...`
      - `do_usb_start` calls `usb_init` to initialize and scan usb
  - `bootdelay_process` gets boot cmd
    - boot delay defaults to `CONFIG_BOOTDELAY`, which is 2 seconds
    - it returns `bootcmd` env which defaults to `CONFIG_BOOTCOMMAND`, which
      is `bootflow scan`
  - `autoboot_command` autoboots
    - `abortboot` calls `abortboot_single_key` to wait for autoboot abort
      - console: `Hit any key to stop autoboot:  <seconds>`
    - `run_command_list` runs the commands
  - `cli_loop` prompts for `CONFIG_SYS_PROMPT` for interactive shell

## Standard Boot

- <https://docs.u-boot.org/en/stable/develop/bootstd.html>
- configs
  - `CONFIG_BOOTSTD` is enabled by default to show the config items
  - `CONFIG_BOOTSTD_DEFAULTS` enables commonly needed features
    - it enables `CONFIG_BOOTMETH_EXTLINUX` and `CONFIG_BOOTMETH_EXTLINUX_PXE`
      which are what we want
    - it selects `CONFIG_BOOT_DEFAULTS` which selects
      `CONFIG_BOOT_DEFAULTS_CMDS` which implies `CONFIG_USE_BOOTCOMMAND`
    - as a result, `CONFIG_BOOTCOMMAND` defaults to `bootflow scan`
  - `CONFIG_BOOTSTD_FULL` enables additional cmds
  - `CONFIG_BOOTSTD_BOOTCOMMAND` affects the default bootcmd
  - `CONFIG_BOOTSTD_PROG` causes `main_loop` to call `bootstd_prog_boot`
    directly to boot
- autoboot
  - `CONFIG_AUTOBOOT` is enabled by default
    - `main_loop` calls `autoboot_command` with the string from `bootcmd` env
    - the default value of `bootcmd` env is `bootflow scan`
  - `U_BOOT_CMD_WITH_SUBCMDS(bootflow, ...)` defines the `bootflow` command
    - `do_bootflow_scan` calls `bootflow_scan_first` and `bootflow_scan_next`
      to loop over all bootflows
      - it calls `bootdev_add_bootflow`
      - it calls `bootflow_run_boot` to boot each bootflow in turn
        - this calls `bootmeth_boot`
- `bootflow_scan_first`
  - `bootmeth_setup_iter_order` collects all `UCLASS_BOOTMETH`
    - `bootmeth_efi_mgr`
    - `bootmeth_efi` looks for `/EFI/BOOT/bootaa64.efi`
    - `bootmeth_extlinux` looks for `extlinux/extlinux.conf`
    - `bootmeth_script` looks for `boot.scr.uimg` or `boot.scr`
    - `bootmeth_pxe`
  - `bootdev_setup_iter` finds the first bootdev
    - it seems to support `UCLASS_BOOTSTD`, bootdev hunter, and
      `UCLASS_BOOTDEV`
    - if `boot_targets` env is set, `bootstd_get_bootdev_order` returns the
      env and `bootdev_next_label` tries them in order
    - `bootdev_next_prio` finds and probes `UCLASS_BOOTDEV`
    - `dm_scan_other` adds a default `UCLASS_BOOTSTD` device and a
      `UCLASS_BOOTMETH` device for each `UCLASS_BOOTMETH` driver
    - mmc registers a boodev hunter with `BOOTDEV_HUNTER(mmc_bootdev_hunter)`
  - `bootflow_check` calls `bootmeth_get_bootflow`
- `bootflow_scan_next` finds the first partition of the current device, or the
  first partition of the next device, or fail
- `bootmeth_get_bootflow` calls `read_bootflow` callback
  - `extlinux_read_bootflow` reads `/extlinux/extlinux.conf` or
    `/boot/extlinux/extlinux.conf` on the partition
    - the paths are from `default_prefixes` and `EXTLINUX_FNAME`
  - `efi_mgr_read_bootflow` finds `BootOrder` from efi vars
    - `efi_init_obj_list` calls `efi_init_variables` calls `efi_var_from_file`
      - it reads `EFI_VAR_FILE_NAME` (`ubootefi.var`)
  - `extlinux_pxe_read_bootflow` calls `pxe_get` to retrieve the boot file
    - it uses `do_get_tftp` which waits for the network
    - `PXELINUX_DIR` is `pxelinux.cfg/`
    - `pxe_default_paths` has various default filenames
- `bootmeth_boot` calls `boot` callback
  - `extlinux_boot` calls `pxe_process` to parse and boot the entry
    - the format of `extlinux.conf` appears to be based on pxelinux, extlinux,
      and
      <https://uapi-group.org/specifications/specs/boot_loader_specification/>
  - `efi_mgr_boot` calls `efi_bootmgr_run`
  - `extlinux_pxe_boot` also calls `pxe_process`

## `extlinux.conf`

- `extlinux_boot` calls `pxe_process` to parse the `extlinux.conf` and boot
- top-level keywords are
  - `menu title` is parsed to `cfg->title`
  - `menu background` is parsed to `cfg->bmp`
  - `timeout` is parsed to `cfg->timeout`
  - `default` and `ontimeout` are parsed to `cfg->default_label`
  - `prompt` is parsed to `cfg->prompt`
  - `include` includes another file
  - `label` creates a new lable and is pased to `label->name`
- label-level keywords are
  - `menu default` is parsed to `cfg->default_label`
  - `menu label` is parsed to `label->menu`
    - this is the pretty name
  - `kernel` and `linux` are parsed
    - the full string is parsed to `label->kernel_label`
    - if the full string contains `#`
      - `label->kernel` is those before `#`
      - `label->config` is `#` and those after `#`
    - otherwise,
      - `label->kernel` is the same as `label->kernel_label`
      - `label->config` is null
  - `append` is parsed to `label->append`
  - `initrd` is parsed to `label->initrd`
  - `fdt` and `devicetree` are parsed to `label->fdt`
  - `fdtdir` and `devicetreedir` are parsed to `label->fdtdir`
  - `fdtoverlays` and `devicetree-overlay` are parsed to `label->fdtoverlays`
  - `localboot` is parsed to `label->localboot_val` and sets
    `label->localboot`
  - `ipappend` is parsed to `label->ipappend`
  - `kaslrseed` sets `label->kaslrseed`
- `handle_pxe_menu`
  - `cfg->bmp` specifies a bmp file to draw as a background
  - `pxe_menu_to_menu`
    - `cfg->title` specifies the menu title
    - `cfg->timeout` specifies how many deciseconds to wait for user input
    - `cfg->prompt` specifies whether to show the menu
      - if true, it always shows the menu even when timeout is 0
      - if false, it shows the menu only when there is user input
    - `cfg->default_label` specifies the default label to boot
  - `menu_get_choice` returns the chosen label interactively
  - `label_boot` boots the chosen label
    - if `label->localboot`, `label_localboot` boots using `$localcmd`
    - file loading
      - `label->kernel` is loaded to `$kernel_addr_r`
      - `label->initrd` is loaded to `$ramdisk_addr_r`
    - kernel cmdline
      - `label->append` is set to `$bootargs`
      - `label->ipappend` appends netboot args to it
    - fdt
      - if `label->fdt`, it is the file to load
      - if `label->fdtdir`,
        - if `$fdtfile`, it is the file to load relative to fdtdir
        - otherwise, `$fdtdir/$soc-$board.dtb` is the file to load
      - the fdt file is loaded to `$fdt_addr_r`
      - if `label->kaslrseed`, it patches `kaslr-seed` node
      - if `label->fdtoverlays`, it loads overlays to `$fdtoverlay_addr_r` and
        patches them in one by one
    - it boots with one of `bootm`, `booti`, `bootz`, or `zboot`
      - `bootm` boots an FIT or legacy image
        - this is used when `label->kernel` is created by `mkimage`
      - `booti` boots raw kernel `Image` or `Image.gz`
        - `booti_start` calls `image_decomp_type` and `image_decomp` to
          decompress the kernel if it is compressed
        - `bootm_find_images` calls `boot_get_ramdisk` to parse initrd and
          calls `boot_get_fdt` to parse fdt
          - `CONFIG_SUPPORT_RAW_INITRD` is typically enabled and initrd can be
            raw
          - fdt has the same binary format as fit and is parsed as fit
      - `bootz` boots raw kernel `zImage`
      - `zboot` boots raw kernel `bzImage`

## Usage

- Environment Variable Commands
  - `printenv`
  - `setenv bootargs 'console=ttyS0,115200'` sets kernel cmdline
    - or `console=tty0` or both
  - `saveenv`
- Storage Commands
  - `usb reset` rescans USB devices
  - `usb storage` lists USB storage devices
  - `usb part` lists USB storage partitions
  - `ls usb 0:1` lists files in USB storage device 0 partition 1
  - `load usb 0:1 0x3000000 vmlinuz` loads kernel to 0x3000000
  - `load usb 0:1 0x6000000 initramfs.img` loads initramfs to 0x6000000
- Boot Commands
  - `zboot 0x3000000 - 0x6000000 ${filesize}` boots bzImage at 0x3000000 with
    initramfs at 0x6000000
    - note that initramfs size is required and is in hex
    - `Valid Boot Flag`
    - `Setup Size = 0x00003e00`
    - `Magic signature found`
    - `Using boot protocol version 2.0f`
    - `Linux kernel version ...`
    - `Building boot_params at 0x00090000`
    - `Loading bzImage at address 100000 (9398496 bytes)`
    - `Magic signature found`
    - `Kernel command line: "console=ttyS0,115200"`
    - `Magic signature found`
    - `Starting kernel ...`
    - after the kernel initializes the console, it prints the banner
      - `[    0.000000] Linux version ...`
  - `boot` runs the commands in `bootcmd`
- Automatic Boot
  - `setenv bootdelay 5`
  - `setenv bootcmd '...'` for semicolon-separated commands
  - `setenv bootargs '...'` for kernel cmdline
  - it will run `boot` after the delay
- On my testing machine,
  - u-boot is really slow because of fb init and updates
  - there is no `saveenv`
  - mmc is not supported; has to use usb storage
  - loading kernel/initramfs to 0x1000000/0x2000000 does not work
    - initramfs seems to be corrupted
  - `console=ttyS0,115200` stops working after switching from Debian kernel to
    Arch kernel
    - probably just a loglevel issue?
  - login takes ~20 seconds for some unknown reason

## `mkimage`

- defaults
  - `params.os` defaults to `IH_OS_LINUX`
  - `params.arch` defaults to `IH_ARCH_PPC`
  - `params.type` defaults to `IH_TYPE_KERNEL`
  - `params.comp` defaults to `IH_COMP_GZIP`
  - `params.dtc` defaults to `-I dts -O dtb -p 500`
- generic options
  - `-l` updates `params.lflags`
  - `-q` updates `params.quiet`
  - `-s` updates `params.skipcpy`
  - `-v` updates `params.vflag`
  - `-V` prints version
- image options (mostly for legacy image)
  - `-a` updates `params.addr`
  - `-A` updates `params.arch` and `params.Aflag`
    - `arm` is `IH_ARCH_ARM`
    - `arm64` is `IH_ARCH_ARM64`
    - `x86` is `IH_ARCH_I386`
    - `x86_64` is `IH_ARCH_X86_64`
  - `-C` updates `params.comp`
    - `gzip` is `IH_COMP_GZIP`
    - `zstd` is `IH_COMP_ZSTD`
    - `lz4` is `IH_COMP_LZ4`
  - `-d` updates `params.datafile` and `params.dflag`
  - `-e` updates `params.ep` and `params.eflag`
  - `-n` updates `params.imagename`
  - `-O` updates `params.os`
    - `linux` is `IH_OS_LINUX`
    - `u-boot` is `IH_OS_U_BOOT`
    - `efi` is `IH_OS_EFI`
    - `elf` is `IH_OS_ELF`
  - `-R` updates `params.imagename2`
  - `-T` updates `params.type` (if no `-F`) or `params.fit_image_type`
    - `kernel` is `IH_TYPE_KERNEL`
    - `ramdisk` is `IH_TYPE_RAMDISK`
    - `multi` is `IH_TYPE_MULTI`
    - `firmware` is `IH_TYPE_FIRMWARE`
    - `script` is `IH_TYPE_SCRIPT`
    - `filesystem` is `IH_TYPE_FILESYSTEM`
    - `flat_dt` is `IH_TYPE_FLATDT`
    - `rkimage` is `IH_TYPE_RKIMAGE`
    - `rksd` is `IH_TYPE_RKSD`
    - `rkspi` is `IH_TYPE_RKSPI`
  - `-x` updates `params.xflag`
- fit image options
  - `-b` updates `params.content_*`
    - it adds a `content_info` of type `IH_TYPE_FLATDT` to the list
  - `-B` updates `params.bl_len`
  - `-D` updates `params.dtc`
  - `-E` updates `params.external_data`
  - `-f` updates `params.datafile` and implies `-F`
    - unless it is `auto` or `auto-conf`, which updates `params.auto_fit`
  - `-F` updates `params.type` to `IH_TYPE_FLATDT` and `params.fflag`
  - `-i` updates `params.fit_ramdisk`
  - `-p` updates `params.external_offset`
  - `-t` updates `params.reset_timestamp`
- signing options
  - `-c` updates `params.comment`
  - `-g` updates `params.keyname`
  - `-G` updates `params.keyfile`
  - `-k` updates `params.keydir`
  - `-K` updates `params.keydest`
  - `-N` updates `params.engine_id`
  - `-o` updates `params.algo_name`
  - `-r` updates `params.require_keys`
- `U_BOOT_IMAGE_TYPE` registers an image type
  - `defimage` handles legacy types (all types before `IH_TYPE_FLATDT`)
    - there is a 64-byte header, `legacy_img_hdr`
      - `ih_size` is the payload size
      - `ih_load` is the pyaload load addr from `params.addr`
      - `ih_ep` is the payload entrypoint addr from `params.ep`
      - `ih_os` is from `params.os`
      - `ih_arch` is from `params.arch`
      - `ih_type` is from `params.type`
      - `ih_comp` is from `params.comp`
      - `ih_name` is the descriptive name from `params.imagename`
      - also magic, header and data checksums, date, etc.
    - when the type is `IH_TYPE_MULTI`, there is an array of dwords
      - it encodes the file sizes followed by 0 to terminate the array
      - `params.datafile` is a colon-separated list of files
    - payload data
  - `fitimage` handles `IH_TYPE_FLATDT`
  - `rkimage` handles `IH_TYPE_RKIMAGE`
  - `rksd` handles `IH_TYPE_RKSD`
  - `rkspi` handles `IH_TYPE_RKSPI`

## FIT Image

- <https://fitspec.osfw.foundation/>
- 2. Flattened Image Tree (FIT) Format
  - in the device tree world, `.dts` is compiled to `.dtb` which can be
    parsed into `fdt`
  - in the fit world, `.its` is compiled to `.itb` which can be parsed
    into `fit`
    - the newer name for `.itb` is `.fit`
  - the root node
    - properties: `description`, `timestamp`, and `#address-cells`
    - child nodes: `images` and `configurations`
  - the `images` node is a container to `image-N` nodes
  - the `configurations` node
    - properties
      - `default` is the default choise
    - child nodes: `config-N` and `signature-N`
  - the `image-N` node
    - properties
      - `description` is the descriptive name
      - `type` is the same as `-T`
      - `compression` is the same as `-C`
      - `data` is the same as `-d`
        - the payload is embedded in-place in the fit image, which can
          slow down fit image parsing
        - it is possible to append the payload after the fit image, known
          as external data
          - `data-size` is the size of the payload
          - `data-offset` is the offset of the payload
          - `data-position` is the loaded addr of the payload
      - `os` is the same as `-O`
      - `arch` is the same as `-A`
      - `entry` is the same as `-e`
      - `load` is the same as `-a`
      - `compatible` is only used when loading requires special treatment
      - `phase` is `spl` or `u-boot`
    - child nodes: `hash-N` and `signature-N`
  - the `config-N` node
    - properties
      - `description` is the descriptive name
      - `kernel` selects a `image-N` of type `kernel`
      - `firmware` selects a `image-N` of type `firmware`
      - `fdt` selects a `image-N` of type `flat_dt`
      - `fpga` selects a `image-N` of type `fpga`
      - `script` selects a `image-N` of type `script`
      - `loadables` are additional `image-N`s to load
      - `compatible` is the root compatible string of `fdt`
        - e.g., `rk3588s-orangepi-5.dts` has `xunlong,orangepi-5`
    - child nodes: `signature-N`
- 3. Flattened Image Tree (FIT) Usage
  - Load a FIT into memory
    - this loads the FIT image
    - in the case external data is used, the data loaded is small-ish
  - Select a configuration to boot
    - it is common for an FIT image to have one kernel and mulitple dtbs, and
      this step can pick the dtb to use
  - Load the images from the selected configuration
    - this can load the kernel image, the dtb, the initrd, etc. as specified
      by the configuration
  - Fix up the devicetree
    - this step can patch the `/chosen` node
      - the `bootargs` prop is the kernel cmdline
      - the `initrd-start` and `initrd-end` props are addr of initrd
    - there is also the concept of overlays to enable/disable hw blocks
  - Jump to the OS

## Old

- env

    #define CFG_NO_FLASH            1
    #define CFG_ENV_IS_IN_NAND      1
    #define CFG_ENV_SIZE            0x40000 /* 128k Total Size of Environment Sector
    #define CFG_ENV_OFFSET_OOB      1       /* Location of ENV stored in block 0 OOB
    #define CFG_PREBOOT_OVERRIDE    1       /* allow preboot from memory */
    #define NAND_MAX_CHIPS          1
    #define CFG_NAND_BASE           0x4e000000
    #define CFG_MAX_NAND_DEVICE     1
    
    CFG_ENV_OFFSET is defined to be env_offset, which is set to CFG_OFFSET_OOB

- all starts at `lib_arm:start_armboot`
- `env_init` set directly `gd->env_addr` to `default_environment` and `gd->env_valid = 1`
- after `nand_init`, `env_relocate` is called, which

    env_ptr is set to malloc(some size);
	env_get_char = env_get_char_memory;
	if (preboot_override) gd->env_valid = 0;
	if (gd->env_valid) env_relocate_spec() else default_env();
	gd->env_addr = env_ptr->data;
- `Found Environment offset in OOB..` -> try to read env from nand
  - if not `*** Warning - bad CRC or NAND, using default environment\n\n` -> env from nand is used
`main_loop`

    if preboot_override, run_command(p);
    bootdelay set, s = bootcmd, then
    if (!nobootdelay && bootdelay >= 0 && s && !abortboot (bootdelay)) run_command(s);
    	abortboot return true when any key pressed
- `nand` command:
  - many nand subcommands indirectly calls `mtdparts_init()`, which gets parts
    info from `getenv("mtdparts")` (and others)
- `dynenv` command:
  - it indirectly calls into `mtdparts_init` too.  On return, `CFG_ENV_OFFSET` is
    set to the new address
- `saveenv` save env to `CFG_ENV_OFFSET`
