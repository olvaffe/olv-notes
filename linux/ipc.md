Linux ipc
=========

## System V IPC

- sysvipc(7)
- message queues
  - `msgget(key, flags)` returns the msg queue id
    - key can be generated by `ftok` such that two processes can easily share
      the msg queue
    - in a sense, key is like the filename and msqid is like an fd
  - msgctl manipulates a msg queue
    - file-like access control
    - removal
  - `msgsnd(msqid, ...)` sends a user-defined message using the msg queue id
  - `msgrcv(msqid, ...)` receives the message
  - `ipc/msg.c`
    - user-defined key is used to look up or create a new `msg_queue`
    - `msg_queue` has an id that is returned to userspace
- semaphore sets
  - `semget` returns the semaphore set id
    - the number of semaphores in the set is user-specified
  - `semctl`
  - `semop` defines three ops: wait, signal, get
  - `ipc/sem.c`
    - every semaphore in a set is essential an int
- shared memory
  - `shmget` returns the shm id
    - the size is user-specified
  - `shmctl` to access control and remove
  - `shmat` maps
  - `shmdt` unmaps
  - `ipc/shm.c`
    - a shm is a shmem internally
- each sysvipc object is global with access control
- checking out `ipcs` or `/proc/sysvipc`, only shm is still in use on my
  system

## POSIX IPC

- `mq_overview(7)`
  - `mq_open` to open a mq
  - `mq_send` and `mq_receive` to send and receive
  - `ipc/mqueue.c`
    - internally mount `mqueue` fs
    - open/send/receive/close works on files in the mqueue fs
    - userspace can mount mqueue too
- `sem_overview(7)`
  - `sem_open` opens `/dev/shm/sem.<name>`
  - `sem_post` and `sem_wait` to increment and decrement
  - `/dev/shm` must be mounted
  - no kernel code; a sem is a futex in a shm
- `shm_overview(7)`
  - `shm_open` opens `/dev/shm/<name>`
  - ftruncate to set the size
  - mmap/munmap works
  - `/dev/shm` must be mounted
  - no kernel code
- checking out `/dev/mqueue` and `/dev/shm`, there is no user on my system
